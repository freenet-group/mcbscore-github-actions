name: Release

on:
  pull_request:
    types: [ closed ]
  workflow_dispatch:
    inputs:
      gradleOptions:
        description: Zusätzliche optionale Gradle Parameter
        required: false
      branch:
        description: 'Von welchem Branch soll ein Release gebaut werden z.B. "feature/ABRMS-*" "oder bugfix/MCBS-*"?'
        required: false
      ticket: 
        description: 'Welches Ticket (MCBS-1234 / ABRMS-1234) soll für das Release verwendet werden?'
        required: true
      version:
        description: 'Welche Version für das neue Release z.B. "8.32.1"?'
        required: false
      pre-release:
        default: false
        description: 'Ist dies ein Pre-Release?'
        required: false
        type: boolean

jobs:
  release:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: [ self-hosted, k8s ]
    env:
      ACTIONS_REPOSITORY: freenet-group/mcbscore-github-actions
      ACTIONS_PATH: mcbscore/github
      KEY_SERVER: ${{ secrets.CERT_SERVER }}
      TZ: Europe/Berlin
      LANG: de_DE.UTF-8
    steps:
      - name: locale konfigurieren
        run: sudo locale-gen "$LANG" && sudo update-locale LANG="$LANG"

      - name: Repository auschecken
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: AWS Secrets auslesen und in ENV schreiben
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_user = USER,
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbstest_credentials = MCBSTEST_CREDENTIALS,
            /github/secrets/mcbstest_jiracloud_credentials = MCBSTEST_JIRACLOUD_CREDENTIALS,
            /github/common/jira/jira_cloud_url = JIRA_CLOUD_URL,
            /github/common/sonar/api_url = SONAR_API_URL,
            /github/secrets/dependencytrack_protocol = DEPENDENCYTRACK_PROTOCOL,
            /github/secrets/dependencytrack_hostname = DEPENDENCYTRACK_HOSTNAME,
            /github/secrets/dependencytrack_port = DEPENDENCYTRACK_PORT,
            /github/secrets/dependencytrack_api_key = DEPENDENCYTRACK_API_KEY

      - name: workflow.properties einlesen und in ENV schreiben
        shell: bash
        run: |
          cat ./.github/workflow.properties >> $GITHUB_ENV

      - name: Interne mcbscore-github-actions local auschecken
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ACTIONS_REPOSITORY }}
          token: ${{ env.TOKEN }}
          path: ${{ env.ACTIONS_PATH }}

      - name: Workflow initialisieren
        uses: ./mcbscore/github/actions/init-workflow
        with:
          installJava: true
          installGithubCli: true
          installJq: true

      - name: keystore-files kopieren
        if: env.KEY_SERVER != ''
        shell: bash
        run: |
          certServer='${{ env.KEY_SERVER }}'
          scp -p "${certServer}:oidc/keys/keystore.jwks" "${certServer}:oidc/keys/samlKeystore.jks" docker/home/oidc/keys/
          ls -l docker/home/oidc/keys

      - name: Release Label einlesen
        id: release-label
        uses: actions-ecosystem/action-release-label@v1
        with:
          label_prefix: 'release:'

      - name: Letztes Release Tag holen
        id: get-latest-tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        with:
          initial_version: 0.0.0
          semver_only: true

      - name: Semantic Version hochzählen
        id: bump-semver
        uses: actions-ecosystem/action-bump-semver@v1
        with:
          current_version: ${{ steps.get-latest-tag.outputs.tag  }}
          level: ${{ steps.release-label.outputs.level || 'patch' }}

      - name: Semantic Version überschreiben, wenn eine spezifische Version angegeben wurde
        id: version-calculation
        run: |
          # Setze die neue kalkulierte Version in die Outputs
          echo "new_version=${{ steps.bump-semver.outputs.new_version }}" >> $GITHUB_OUTPUT

          # Überschreibe die neue kalkulierte Version, wenn eine spezifische Version angegeben wurde
          if [ -n "${{ github.event.inputs.version }}" ]; then
            echo "new_version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Component Version setzen (legacy - Für die Kompatibilität mit alten Actions)
        shell: bash
        run: |
          echo "COMPONENT_VERSION=${{ steps.version-calculation.outputs.new_version }}" >> $GITHUB_ENV
          echo "RAW_VERSION=${{ steps.version-calculation.outputs.new_version }}" >> $GITHUB_ENV
          echo "BUILD_TYPE=RELEASE" >> $GITHUB_ENV

      - name: Neuen Versions-Tag einchecken
        uses: actions-ecosystem/action-push-tag@v1
        with:
          tag: ${{ steps.version-calculation.outputs.new_version }}
          message: '${{ steps.version-calculation.outputs.new_version }}: PR #${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}'

      - name: Release Version in DB Changes eintragen
        if: hashFiles('.github/**/dbChanges.yml') != ''
        shell: bash
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          find ./${{ env.DB_CHANGES_DIRECTORY }} -type f -exec sed -i 's/{releaseVersion}/${{ steps.version-calculation.outputs.new_version }}/g' {} +
          changesDetected=`git status --porcelain`
          if [ -n "$changesDetected" ]
          then
            echo "Committing changes"
            git commit -am "Release Version in DB Changes eingetragen"
            git push
          fi
          git tag -f -a sql-${{ env.TAG_PREFIX }}${{ steps.version-calculation.outputs.new_version }} -m "tagging sql-${{ env.TAG_PREFIX }}${{ steps.version-calculation.outputs.new_version }}"

      - name: Gradle Build mit Sonar Upload und CyclonedxBom (SBOM)
        uses: ./mcbscore/github/actions/gradle-build
        with:
          sonarqubeToken: ${{ secrets.SONARQUBE_TOKEN }}
          sonarqubeUrl: ${{ secrets.SONARQUBE_HOST_URL }}
          enableSonarCheckOnAllBranches: true
          gradleOptions: ${{ github.event.inputs.gradleOptions }}

      - name: Sonar-Coverage abholen
        id: fetch-coverage
        if: ${{ (env.JAVA_VERSION != '8') && (env.COVERAGE_APP != '') }}
        uses: ./mcbscore/github/actions/sonar-check
        with:
          sonarUrl: ${{ env.SONAR_API_URL }} 
          sonarCredentials: ${{ env.MCBSTEST_CREDENTIALS }}
          projectKeyPath: ${{ env.COVERAGE_PATH }}
          projectKeyName: ${{ env.COVERAGE_APP }}
          atlassianToolsVersion: ${{ env.ATLASSIAN_DEVELOPER_TOOLS_VERSION }}

      - name: Issue-List Alternative aus Diff zur neuen Version erzeugen
        id: jira_keys
        uses: varnerknut/jira-extract-issue-keys-from-tags@1.3
        with:
          token: ${{ env.TOKEN }}
          head-tag: ${{ steps.version-calculation.outputs.new_version }}

      - name: Release-Template einlesen und ausfüllen
        id: update_release_template
        run: |
          template_file=".github/templates/release_template.md"
          issueList=""
          issueListLines=""
          linkIssuesListLines=""
          allComponentList=""
          dependencyList=""
          linkedIssuesListLines=""
          epicList=""
          
          # Setting default outputs
          echo "issue_list=" >> "$GITHUB_OUTPUT"
          echo "renovate=false" >> "$GITHUB_OUTPUT"
          echo "renovate_title=" >> "$GITHUB_OUTPUT"
          echo "epic_list=" >> "$GITHUB_OUTPUT"
          echo "epic_due_date=" >> "$GITHUB_OUTPUT"
          echo "ms_configuration=false" >> "$GITHUB_OUTPUT"
          echo "ms_deployment=false" >> "$GITHUB_OUTPUT"
          echo "db_changes=false" >> "$GITHUB_OUTPUT"
          echo "dependencies=false" >> "$GITHUB_OUTPUT"
          
          # Alle Issues auslesen
          uniqueIssueList=$(echo "${{ steps.jira_keys.outputs.issue-keys }}" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')
          uniqueIssueList=${uniqueIssueList#"[]"}

          # Prüfen ob der Input "ticket" gesetzt wurde, wenn ja, dann hinzufügen
          if [ -n "${{ github.event.inputs.ticket }}" ]; then
            if [ -z "$uniqueIssueList" ]; then
              uniqueIssueList="${{ github.event.inputs.ticket }}"
            else
              # Prüfen ob das Ticket bereits in der uniqueIssueList enthalten ist
              if [! echo "$uniqueIssueList" | grep -q "${{ github.event.inputs.ticket }}"]; then
                uniqueIssueList+=",${{ github.event.inputs.ticket }}"
              fi
            fi
          fi

          # Prüfen ob das label "renovate" im PR gesetzt wurde
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            prNumber=$(jq -r ".pull_request.number" "$GITHUB_EVENT_PATH")
            prLabels=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${prNumber}/labels" | jq -r ".[].name")
            
            # ABRMS-5265 ist ein Renovate-Platzhalterticket für DOGS
            if echo "$prLabels" | grep -q "renovate"; then
              if [ -z "$uniqueIssueList" ]; then
                uniqueIssueList="ABRMS-5265"
              else
                uniqueIssueList+=",ABRMS-5265"
              fi
            fi
          fi
          
          # IssueList / Implemented Issues
          echo "issue_list=$uniqueIssueList" >> "$GITHUB_OUTPUT"
          echo "Folgende Issues werden analysiert $uniqueIssueList"
          IFS=',' read -ra issues <<< "$uniqueIssueList"
          for line in "${issues[@]}"; do
            # Tabellen Eintrag erstellen
            issueNumber=$(echo "$line" | cut -d";" -f1 | xargs)
            echo "$issueNumber wird eingelesen"
          
            # Renovate Ticket überspringen, Rest aber prüfen
            if [ "$issueNumber" = "ABRMS-5265" ]; then
              title="${{ github.event.pull_request.title }}"
              issueListLines+="| ABRMS-5265 | $title | Renovate | Renovate |\n"
              echo "renovate=true" >> "$GITHUB_OUTPUT"
              echo "renovate_title=$title" >> "$GITHUB_OUTPUT"
              continue  # Rest überspringen
            fi
          
            # Jira Ticket einlesen
            echo "Jira API wird zu $issueNumber befragt"
            API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$issueNumber"
            BASIC_AUTH=$(echo -n ${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }} | base64 -w0)
            AUTH_HEADER="Authorization: Basic $BASIC_AUTH"
            issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")
          
            # Extracting the epic name and dueDate
            echo "Epic name for $issueNumber is being extracted"
            epicKey=$(echo "$issue_info" | jq -r '.fields.customfield_10014')
            if [ -n "$epicKey" ] && [ "$epicKey" != "null" ]; then
              if [ -z "$epicList" ]; then
                epicList="$epic_name"
                API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$epic_name"
                epic_issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")
                epic_dueDate=$(echo "$epic_issue_info" | jq -r '.fields.duedate')
                if [ -n "$epic_dueDate" ] && [ "$epic_dueDate" != "null" ]; then
                  echo "epic_due_date=$epic_dueDate" >> "$GITHUB_OUTPUT"
                fi
              else
                epicList="$epicList,$epicKey"
              fi
            fi
          
            # Titel einlesen
            echo "Titel zu $issueNumber extrahieren"
            title=$(echo "$issue_info" | jq -r '.fields.summary')
          
            # Jira-Labels einlesen
            echo "Jira-Labels zu $issueNumber extrahieren"
            jiraLabels=$(echo "$issue_info" | jq -r '.fields.labels[]' | paste -sd ", ")
          
            # Komponenten extrahieren
            echo "Komponenten zu $issueNumber extrahieren"
            componentList=$(echo "$issue_info" | jq -r '.fields.components[].name' | paste -sd ", ")
            allComponentList+=$componentList
          
            # Dependencies extrahieren
            echo "Dependencies zu $issueNumber extrahieren"
            custom_field_value=$(echo "$issue_info" | jq -r '.fields.customfield_10686')
            if [ ! -z "$custom_field_value" ] && [ "$custom_field_value" != "null" ]; then
              dependencyList+="\t * :warning: $issueNumber: $custom_field_value\n"
            else
              echo "No dependencies found for issue $issueNumber"
            fi

            # Ticket Tabelle ausfüllen
            echo "Tabelleneintrag zum Ticket $issueNumber wird erstellt"
            issueListLines+="| $issueNumber | $title | $jiraLabels | $componentList |\n"
          
            # Verknüpfte Tickets
            echo "Verknüpfte Tickets zu $issueNumber einlesen und Tabelle befüllen"
            for k in $(jq '.fields.issuelinks | keys | .[]' <<<"$issue_info"); do
              linkedIssue=$(jq -r ".fields.issuelinks[$k]" <<<"$issue_info");
          
              # Prüfe auf ausgehende Links
              isOutward=$(jq 'has("outwardIssue")' <<<"$linkedIssue")
              if $isOutward; then
                linkedRelation=$(jq -r '.type.outward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.outwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.outwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.outwardIssue.fields.status.name' <<<"$linkedIssue")
              else
                linkedRelation=$(jq -r '.type.inward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.inwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.inwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.inwardIssue.fields.status.name' <<<"$linkedIssue")
              fi
                linkedIssuesListLines+="| $linkedIssueNumber | $linkedSummary | $linkedStatus | $linkedRelation |\n"
          
                echo "Verknüpftes Ticket erkannt: $linkedIssueNumber - $linkedSummary"
            done
          done
          
          # Platzhalter austauschen
          echo "Platzhalter im Template austauschen"
          
          ## Tabellen
          echo "IssueList setzen"
          echo "$issueListLines"
          sed -i "s#<!-- IMPLEMENTED_ISSUES_PLACEHOLDER -->#$issueListLines#" "$template_file"
          echo "Verlinkte Tickets setzen"
          echo "$linkedIssuesListLines"
          sed -i "s/<!-- IMPLEMENTED_LINKED_ISSUES_PLACEHOLDER -->/$linkedIssuesListLines/" "$template_file"
          
          ## EPIC
          echo "EPIC setzen"
          if [ -n "$epicList" ]; then
            echo "epic_list=$epicList" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/$epicList/" "$template_file";
          else
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/:white_check_mark: Keine Änderung/" "$template_file";
          fi
          
          ## Java
          echo "Java setzen"
          sed -i 's/<!-- JAVA_VERSION_PLACEHOLDER -->/${{ env.RELEASENOTES_JAVA_RELEASE }}/' "$template_file";
          
          ## MS-Configuration
          echo "MS-Configuration Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-configuration"; then
            echo "ms_configuration=true" >> "$GITHUB_OUTPUT"
            url="${{ github.SERVER_URL }}/ms-configuration"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:warning: Achtung [MS-Configuration]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## MS-Deployment
          echo "MS-Deployment Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-deployment"; then
            echo "ms_deployment=true" >> "$GITHUB_OUTPUT"
            url="${{ github.SERVER_URL }}/ms-deployment"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:warning: Achtung [MS-Deployment]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## DB-Changes
          echo "DB-Changes Flag setzen"
          if echo "$allComponentList" | grep -iq "sql update script"; then
            echo "db_changes=true" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- DB_CHANGES_PLACEHOLDER -->/:warning: Achtung DB-Changes sind notwendig/" "$template_file";
          else 
            sed -i 's/<!-- DB_CHANGES_PLACEHOLDER -->/:white_check_mark: Keine DB-Changes/' "$template_file";
          fi
          
          ## Dependencies
          echo "Dependencies setzen"
          if [ -n "$dependencyList" ]; then
            echo "dependencies=true" >> "$GITHUB_OUTPUT"
            dependencyList="\n$dependencyList"
            sed -i "s/<!-- DEPENDENCIES_PLACEHOLDER -->/$dependencyList/" "$template_file";
          else 
            sed -i 's/<!-- DEPENDENCIES_PLACEHOLDER -->/:white_check_mark: Keine Dependencies/' "$template_file";
          fi
          
          ## JUnit
          echo "JUnit setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- JUNIT_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Cucumber
          echo "Cucumber setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- CUCUMBER_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Coverage
          echo "Coverage setzen"
          sed -i 's/<!-- COVERAGE_PLACEHOLDER -->/${{ steps.fetch-coverage.outputs.coverage }}/' "$template_file";
          git push --tags -f

      - name: Release erstellen
        uses: softprops/action-gh-release@v2
        with:
          body_path: ".github/templates/release_template.md"
          files: |
            ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ steps.version-calculation.outputs.new_version }}.jar
            ${{ env.DEPENDENCYTRACK_BOM_PATH }}${{ env.DEPENDENCYTRACK_BOM_NAME }}
          generate_release_notes: true
          name: ${{ steps.version-calculation.outputs.new_version }}
          prerelease: ${{ github.event.inputs.pre-release == 'true' }}
          tag_name: ${{ steps.version-calculation.outputs.new_version }}
          token: ${{ env.TOKEN }}

      - name: Upload API Doc
        uses: ./mcbscore/github/actions/upload-api-doc-assets
        with:
          componentVersion: ${{ steps.version-calculation.outputs.new_version }}
          apiDocYmlPattern: ${{ env.API_DOC_YAML_PATTERN }}

      - name: Login GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_R_PACKAGES }}

      - name: Docker Image erzeugen
        uses: ./mcbscore/github/actions/create-microservice-docker-image
        with:
          componentName: ms-${{ env.COMPONENT }}
          componentVersion: ${{ steps.version-calculation.outputs.new_version }}
          jar: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ steps.version-calculation.outputs.new_version }}.jar
          javaVersion: ${{ env.JAVA_VERSION }}

      - name: Deployment Workflow starten
        id: deployment
        uses: benc-uk/workflow-dispatch@v1.2.3
        with:
          workflow: Deployment
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "environment": "dev",
              "component": "${{ env.COMPONENT }}", 
              "componentVersion": "${{ steps.version-calculation.outputs.new_version }}"
            }

      - name: Deployment Workflow Status prüfen
        run: |
          # Maximal 30 Checks, alle 30 Sekunden, also 15 Minuten maximal
          MAX_CHECKS=30  # Number of checks before timeout, for 15 minutes total.
          counter=0
          INITIAL_SLEEP=60
          RETRY_SLEEP=30
          
          echo "Starting the Check Deployment Workflow Status..."
          sleep $INITIAL_SLEEP  # 1 Minute warten, damit der Workflow gestartet werden kann

          # Workflow Läufe abrufen
          echo "Fetching workflow runs for workflow ID: ${{ steps.deployment.outputs.workflowId }}"
          WORKFLOW_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                          "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ steps.deployment.outputs.workflowId }}/runs")
          
          # Letzten Workflow Run ermitteln
          LATEST_RUN=$(echo "$WORKFLOW_RUNS" | jq '.workflow_runs[0]')  # Assuming the first run is the latest
          RUN_ID=$(echo "$LATEST_RUN" | jq -r '.id')
          RUN_NAME=$(echo "$LATEST_RUN" | jq -r '.name')
          
          echo "Checking run with ID: $RUN_ID and name: $RUN_NAME"
          
          # Status des letzten Workflow Runs prüfen
          while true; do
            # Zähler erhöhen
            counter=$(( counter + 1 ))
            remainingChecks=$(( MAX_CHECKS - counter ))
            remainingTime=$(( remainingChecks * RETRY_SLEEP / 60 ))  # Convert to minutes
          
            echo "Check attempt $counter of $MAX_CHECKS. Remaining checks: $remainingChecks. Time left before timeout: ~$remainingTime minutes."
          
            # Details des Workflow Runs abrufen
            RUN_DETAILS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                                "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID")
          
            RUN_STATUS=$(echo "$RUN_DETAILS" | jq -r '.status')
            CONCLUSION=$(echo "$RUN_DETAILS" | jq -r '.conclusion')
          
            echo "Run Status: $RUN_STATUS, Conclusion: $CONCLUSION"
          
            # Prüfe ob der Workflow noch läuft
            if [[ "$RUN_STATUS" == "queued" || "$RUN_STATUS" == "in_progress" || "$RUN_STATUS" == "null" ]]; then
              echo "Deployment Workflow is $RUN_STATUS..."
          
              if [[ "$counter" -ge "$MAX_CHECKS" ]]; then
                echo "Timeout waiting for the Deployment Workflow."
                exit 1
              fi
          
              sleep $RETRY_SLEEP  # Wait for a specified duration before checking again
            else
              # Wenn nicht "in_progress" oder "queued", dann ist der Workflow abgeschlossen
              break
            fi
          done
          
          # Prüfe ob der Workflow erfolgreich war
          if [[ "$CONCLUSION" == "null" || "$CONCLUSION" != "success" ]]; then
            echo "Deployment Workflow did not complete successfully. Conclusion: $CONCLUSION"
            exit 1
          else
            echo "Deployment Workflow completed with Conclusion: $CONCLUSION"
          fi

      - name: dbChanges Workflow starten
        if: hashFiles('.github/**/dbChanges.yml') != ''
        uses: benc-uk/workflow-dispatch@v1.2.3
        with:
          workflow: DB Changes
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ steps.version-calculation.outputs.new_version }}",
              "tagPrefix": "${{ env.TAG_PREFIX }}"
            }

      - name: Bambi Parameter setzen
        run: |
          BAMBI_ARGS="{ \
            \"renovate\": \"${{ steps.update_release_template.outputs.renovate }}\", \
            \"renovateInfo\": \"${{ steps.update_release_template.outputs.renovate_title }}\", \
            \"ibnDate\": \"${{ steps.update_release_template.outputs.epic_dueDate }}\", \
            \"changesInConfiguration\": \"${{ steps.update_release_template.outputs.ms_configuration }}\", \
            \"changesInDeployment\": \"${{ steps.update_release_template.outputs.ms_deployment }}\", \
            \"dbChanges\": \"${{ steps.update_release_template.outputs.db_changes }}\", \
            \"dependencies\": \"${{ steps.update_release_template.outputs.dependencies }}\" \
          }"
          echo "BAMBI_ARGS=$(echo "$BAMBI_ARGS" | sed 's/"/\\"/g')" >> $GITHUB_ENV

      - name: postBuild Workflow starten
        if: hashFiles('.github/**/postBuild.yml') != '' && ${{ github.event.inputs.pre-release == 'false' }}
        uses: benc-uk/workflow-dispatch@v1.2.3
        with:
          workflow: PostBuild
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "releaseVersion": "${{ steps.version-calculation.outputs.new_version }}",
              "issueList": "${{ steps.update_release_template.outputs.issue_list }}",
              "bambiArgs": "${{ env.BAMBI_ARGS }}",
              "hasSQL": "${{ steps.update_release_template.outputs.db_changes }}",
              "hasConfiguration": "${{ steps.update_release_template.outputs.ms_configuration }}",
              "hasDependencies": "${{ steps.update_release_template.outputs.dependencies }}",
              "hasDeployment": "${{ steps.update_release_template.outputs.ms_deployment }}"
            }

      - name: Tag/Release löschen, wenn der Build fehlgeschlagen ist oder abgebrochen wurde
        if: failure() || cancelled()
        run: |
          if [ -n "${{ steps.version-calculation.outputs.new_version }}" ]; then
            # Wenn bereits ein Release zur Version erstellt wurde, dann lösche dieses. Ansonsten wird nur der Tag gelöscht
            if gh release list --json tagName --jq '.[] | select(.tagName == "${{ steps.version-calculation.outputs.new_version }}")' | grep -q '${{ steps.version-calculation.outputs.new_version }}'; then
              gh release delete ${{ steps.version-calculation.outputs.new_version }} --cleanup-tag --yes
            else
              git tag -d "${{ steps.version-calculation.outputs.new_version }}"
              git push origin ":${{ steps.version-calculation.outputs.new_version }}"
            fi
          fi
        env:
          GH_TOKEN: ${{ env.TOKEN }}
