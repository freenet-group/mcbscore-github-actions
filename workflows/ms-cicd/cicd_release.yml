name: CICD Release

on:
  pull_request:
    types: [ closed ]
  workflow_dispatch:
    inputs:
      release:
        description: 'Release wirklich erstellen?'
        required: true
        type: boolean

jobs:
  release:
    if: github.event.pull_request.merged == true || github.event.inputs.release == 'true'
    runs-on: [ self-hosted, k8s ]

    env:
      ACTIONS_REPOSITORY: freenet-group/mcbscore-github-actions
      ACTIONS_PATH: mcbscore/github
      KEY_SERVER: ${{ secrets.CERT_SERVER }}
      # expected aws properties
      USER: ''
      TOKEN: ''
      MCBSTEST_CREDENTIALS: ''
      JIRA_CLOUD_URL: ''
      DEPENDENCYTRACK_PROTOCOL: ''
      DEPENDENCYTRACK_HOSTNAME: ''
      DEPENDENCYTRACK_PORT: ''
      DEPENDENCYTRACK_API_KEY: ''
      JASYPT_ENCRYPTOR_PASSWORD: ''
      # expected workflow.properties
      JAVA_VERSION: ''
      JIRA_COMPONENT: ''
      JIRA_PROJECT: ''
      ATLASSIAN_DEVELOPER_TOOLS_VERSION: ''
      APPLICATION_JAR_PATH: ''
      APPLICATION_JAR_NAME: ''
      COVERAGE_LIMIT: ''
      COVERAGE_FAIL: ''
      COVERAGE_PATH: ''
      COVERAGE_APP: ''
      COMPONENT: ''
      RELEASENOTES_JAVA_RELEASE: ''
      DEPENDENCYTRACK_BOM: ''

    outputs:
      current_version: ${{ steps.get-latest-tag.outputs.tag  }}
      level: ${{ steps.release-label.outputs.level || 'patch' }}
      new_version: ${{ steps.bump-semver.outputs.new_version }}
      issue_keys: ${{ steps.jira_keys.outputs.issue-keys }}
      issue_list: ${{ steps.update_release_template.outputs.issue_list }}
      renovate: ${{ steps.update_release_template.outputs.renovate }}
      renovate_title: ${{ steps.update_release_template.outputs.renovate_title }}
      epic_list: ${{ steps.update_release_template.outputs.epic_list }}
      epic_due_date: ${{ steps.update_release_template.outputs.epic_dueDate }}
      ms_configuration: ${{ steps.update_release_template.outputs.ms_configuration }}
      ms_deployment: ${{ steps.update_release_template.outputs.ms_deployment }}
      db_changes: ${{ steps.update_release_template.outputs.db_changes }}
      dependencies: ${{ steps.update_release_template.outputs.dependencies }}
      deploymentWorkflowRunId: ${{ steps.deployment.outputs.workflowId }}
      deploymentK8sWorkflowRunId: ${{ steps.deployment_k8s.outputs.workflowId }}
      developerPortalUploadWorkflowRunId: ${{ steps.developerPortalUpload.outputs.workflowId }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: AWS Secrets auslesen
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_user = USER,
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbstest_credentials = MCBSTEST_CREDENTIALS,
            /github/secrets/mcbstest_jiracloud_credentials = MCBSTEST_JIRACLOUD_CREDENTIALS,
            /github/secrets/dependencytrack_protocol = DEPENDENCYTRACK_PROTOCOL,
            /github/secrets/dependencytrack_hostname = DEPENDENCYTRACK_HOSTNAME,
            /github/secrets/dependencytrack_port = DEPENDENCYTRACK_PORT,
            /github/secrets/dependencytrack_api_key = DEPENDENCYTRACK_API_KEY,
            /github/common/jira/jira_cloud_url = JIRA_CLOUD_URL,
            /github/common/sonar/api_url = SONAR_API_URL

      - name: Read workflow.properties
        shell: bash
        run: |
          cat ./.github/workflow.properties >> $GITHUB_ENV

      - name: Checkout mcbscore-github-actions
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ACTIONS_REPOSITORY }}
          token: ${{ env.TOKEN }}
          path: ${{ env.ACTIONS_PATH }}

      - name: Initialize Workflow
        uses: ./mcbscore/github/actions/init-workflow
        with:
          installJava: true
          installGithubCli: true
          installJq: true

      - name: Copy keystore-files
        if: env.KEY_SERVER != ''
        shell: bash
        run: |
          certServer='${{ env.KEY_SERVER }}'
          scp -p "${certServer}:oidc/keys/keystore.jwks" "${certServer}:oidc/keys/samlKeystore.jks" docker/home/oidc/keys/
          ls -l docker/home/oidc/keys

      - name: Release Label einlesen
        id: release-label
        uses: actions-ecosystem/action-release-label@v1
        with:
          label_prefix: 'release:'

      - name: Letzten Release Tag holen
        id: get-latest-tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        with:
          initial_version: 0.0.0
          semver_only: true

      - name: Semantic Version hochzählen
        id: bump-semver
        uses: actions-ecosystem/action-bump-semver@v1
        with:
          current_version: ${{ steps.get-latest-tag.outputs.tag  }}
          level: ${{ steps.release-label.outputs.level || 'patch' }}

      - name: Component Version setzen (legacy)
        shell: bash
        run: |
          echo "COMPONENT_VERSION=${{ steps.bump-semver.outputs.new_version }}" >> $GITHUB_ENV
          echo "RAW_VERSION=${{ steps.bump-semver.outputs.new_version }}" >> $GITHUB_ENV
          echo "BUILD_TYPE=RELEASE" >> $GITHUB_ENV

      - name: Release Version in DB Changes eintragen
        if: hashFiles('.github/**/dbChanges.yml') != ''
        shell: bash
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          find ./${{ env.DB_CHANGES_DIRECTORY }} -type f -exec sed -i 's/{releaseVersion}/${{ steps.bump-semver.outputs.new_version }}/g' {} +
          changesDetected=`git status --porcelain`
          if [ -n "$changesDetected" ]
          then
            echo "Committing changes"
            git commit -am "Release Version in DB Changes eingetragen"
            git push
          fi
          git tag -f -a sql-${{ env.TAG_PREFIX }}${{ steps.bump-semver.outputs.new_version }} -m "tagging sql-${{ env.TAG_PREFIX }}${{ steps.bump-semver.outputs.new_version }}"

      - name: Gradle Build with Sonar Upload and CyclonedxBom (SBOM)
        uses: ./mcbscore/github/actions/gradle-build
        with:
          artifactoryUserName: ${{ secrets.MD_ARTIFACTORY_USER }}
          artifactoryPassword: ${{ secrets.MD_ARTIFACTORY_PW }}
          sonarqubeToken: ${{ secrets.SONARQUBE_TOKEN }}
          sonarqubeUrl: ${{ secrets.SONARQUBE_HOST_URL }}
          enableSonarCheckOnAllBranches: true
          gradleOptions: cyclonedxBom

      - name: Sonar-Coverage abholen
        id: fetch-coverage
        if: ${{ (env.JAVA_VERSION != '8') && (env.COVERAGE_APP != '') }}
        uses: ./mcbscore/github/actions/sonar-check
        with:
          sonarUrl: ${{ env.SONAR_API_URL }}
          sonarCredentials: ${{ env.MCBSTEST_CREDENTIALS }}
          projectKeyPath: ${{ env.COVERAGE_PATH }}
          projectKeyName: ${{ env.COVERAGE_APP }}
          atlassianToolsVersion: ${{ env.ATLASSIAN_DEVELOPER_TOOLS_VERSION }}

      - name: Tag einchecken
        uses: actions-ecosystem/action-push-tag@v1
        with:
          tag: ${{ steps.bump-semver.outputs.new_version }}
          message: '${{ steps.bump-semver.outputs.new_version }}: PR #${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}'

      - name: Issue-List Alternative erzeugen
        id: jira_keys
        uses: varnerknut/jira-extract-issue-keys-from-tags@1.3
        with:
          token: ${{ env.TOKEN }}
          head-tag: ${{ steps.bump-semver.outputs.new_version }}

      - name: Release-Template ausfüllen
        id: update_release_template
        run: |
          template_file=".github/templates/release_template.md"
          issueList=""
          issueListLines=""
          linkIssuesListLines=""
          allComponentList=""
          dependencyList=""
          linkedIssuesListLines=""
          epicList=""
          
          # Alle Issues auslesen
          uniqueIssueList=$(echo "${{ steps.jira_keys.outputs.issue-keys }}" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')
          uniqueIssueList=${uniqueIssueList#"[]"}
          
          # Setting default outputs
          echo "issue_list=" >> "$GITHUB_OUTPUT"
          echo "renovate=false" >> "$GITHUB_OUTPUT"
          echo "renovate_title=" >> "$GITHUB_OUTPUT"
          echo "epic_list=" >> "$GITHUB_OUTPUT"
          echo "epic_due_date=" >> "$GITHUB_OUTPUT"
          echo "ms_configuration=false" >> "$GITHUB_OUTPUT"
          echo "ms_deployment=false" >> "$GITHUB_OUTPUT"
          echo "db_changes=false" >> "$GITHUB_OUTPUT"
          echo "dependencies=false" >> "$GITHUB_OUTPUT"

          # Prüfen ob das label "renovate" gesetzt wurde
          PR_NUMBER=$(jq -r ".pull_request.number" "$GITHUB_EVENT_PATH")
          LABELS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/labels" | jq -r ".[].name")
          
          if echo "$LABELS" | grep -q "renovate"; then
            if [ -z "$uniqueIssueList" ]; then
              uniqueIssueList="ABRMS-5265"
            else
              uniqueIssueList+=",ABRMS-5265"
            fi
          fi
          
          # IssueList / Implemented Issues
          echo "issue_list=$uniqueIssueList" >> "$GITHUB_OUTPUT"
          echo "Folgende Issues werden analysiert $uniqueIssueList"
          IFS=',' read -ra issues <<< "$uniqueIssueList"
          for line in "${issues[@]}"; do
            # Tabellen Eintrag erstellen
            issueNumber=$(echo "$line" | cut -d";" -f1 | xargs)
            echo "$issueNumber wird eingelesen"
          
            # Renovate Ticket überspringen, Rest aber prüfen
            if [ "$issueNumber" = "ABRMS-5265" ]; then
              title="${{ github.event.pull_request.title }}"
              issueListLines+="| ABRMS-5265 | $title | Renovate | Renovate |\n"
              echo "renovate=true" >> "$GITHUB_OUTPUT"
              echo "renovate_title=$title" >> "$GITHUB_OUTPUT"
              continue  # Rest überspringen
            fi
          
            # Jira Ticket einlesen
            echo "Jira API wird zu $issueNumber befragt"
            API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$issueNumber"
            BASIC_AUTH=$(echo -n ${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }} | base64 -w0)
            AUTH_HEADER="Authorization: Basic $BASIC_AUTH"
            issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")
          
            # Extracting the epic name and dueDate
            echo "Epic name for $issueNumber is being extracted"
            epicKey=$(echo "$issue_info" | jq -r '.fields.customfield_10014')
            if [ -n "$epicKey" ] && [ "$epicKey" != "null" ]; then
              if [ -z "$epicList" ]; then
                epicList="$epic_name"
                API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$epic_name"
                epic_issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")
                epic_dueDate=$(echo "$epic_issue_info" | jq -r '.fields.duedate')
                if [ -n "$epic_dueDate" ] && [ "$epic_dueDate" != "null" ]; then
                  echo "epic_due_date=$epic_dueDate" >> "$GITHUB_OUTPUT"
                fi
              else
                epicList="$epicList,$epicKey"
              fi
            fi
          
            # Titel einlesen
            echo "Titel zu $issueNumber extrahieren"
            title=$(echo "$issue_info" | jq -r '.fields.summary')
          
            # Labels einlesen
            echo "Labels zu $issueNumber extrahieren"
            labels=$(echo "$issue_info" | jq -r '.fields.labels[]' | paste -sd ", ")
          
            # Komponenten extrahieren
            echo "Komponenten zu $issueNumber extrahieren"
            componentList=$(echo "$issue_info" | jq -r '.fields.components[].name' | paste -sd ", ")
            allComponentList+=$componentList
          
            # Dependencies extrahieren
            echo "Dependencies zu $issueNumber extrahieren"
            custom_field_value=$(echo "$issue_info" | jq -r '.fields.customfield_10686')
            if [ ! -z "$custom_field_value" ] && [ "$custom_field_value" != "null" ]; then
              dependencyList+="\t * :warning: $issueNumber: $custom_field_value\n"
            else
              echo "No dependencies found for issue $issueNumber"
            fi

            # Ticket Tabelle ausfüllen
            echo "Tabelleneintrag zum Ticket $issueNumber wird erstellt"
            issueListLines+="| $issueNumber | $title | $labels | $componentList |\n"
          
            # Verknüpfte Tickets
            echo "Verknüpfte Tickets zu $issueNumber einlesen und Tabelle befüllen"
            for k in $(jq '.fields.issuelinks | keys | .[]' <<<"$issue_info"); do
              linkedIssue=$(jq -r ".fields.issuelinks[$k]" <<<"$issue_info");
          
              # Prüfe auf ausgehende Links
              isOutward=$(jq 'has("outwardIssue")' <<<"$linkedIssue")
              if $isOutward; then
                linkedRelation=$(jq -r '.type.outward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.outwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.outwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.outwardIssue.fields.status.name' <<<"$linkedIssue")
              else
                linkedRelation=$(jq -r '.type.inward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.inwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.inwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.inwardIssue.fields.status.name' <<<"$linkedIssue")
              fi
                linkedIssuesListLines+="| $linkedIssueNumber | $linkedSummary | $linkedStatus | $linkedRelation |\n"
          
                echo "Verknüpftes Ticket erkannt: $linkedIssueNumber - $linkedSummary"
            done
          done
          
          # Platzhalter austauschen
          echo "Platzhalter im Template austauschen"
          
          ## Tabellen
          echo "IssueList setzen"
          echo "$issueListLines"
          sed -i "s#<!-- IMPLEMENTED_ISSUES_PLACEHOLDER -->#$issueListLines#" "$template_file"
          echo "Verlinkte Tickets setzen"
          echo "$linkedIssuesListLines"
          sed -i "s/<!-- IMPLEMENTED_LINKED_ISSUES_PLACEHOLDER -->/$linkedIssuesListLines/" "$template_file"
          
          ## EPIC
          echo "EPIC setzen"
          if [ -n "$epicList" ]; then
            echo "epic_list=$epicList" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/$epicList/" "$template_file";
          else
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/:white_check_mark: Keine Änderung/" "$template_file";
          fi
          
          ## Java
          echo "Java setzen"
          sed -i 's/<!-- JAVA_VERSION_PLACEHOLDER -->/${{ env.RELEASENOTES_JAVA_RELEASE }}/' "$template_file";
          
          ## MS-Configuration
          echo "MS-Configuration Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-configuration"; then
            echo "ms_configuration=true" >> "$GITHUB_OUTPUT"
            url="${{ github.SERVER_URL }}/ms-configuration"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:warning: Achtung [MS-Configuration]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## MS-Deployment
          echo "MS-Deployment Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-deployment"; then
            echo "ms_deployment=true" >> "$GITHUB_OUTPUT"
            url="${{ github.SERVER_URL }}/ms-deployment"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:warning: Achtung [MS-Deployment]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## DB-Changes
          echo "DB-Changes Flag setzen"
          if echo "$allComponentList" | grep -iq "sql update script"; then
            echo "db_changes=true" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- DB_CHANGES_PLACEHOLDER -->/:warning: Achtung DB-Changes sind notwendig/" "$template_file";
          else 
            sed -i 's/<!-- DB_CHANGES_PLACEHOLDER -->/:white_check_mark: Keine DB-Changes/' "$template_file";
          fi
          
          ## Dependencies
          echo "Dependencies setzen"
          if [ -n "$dependencyList" ]; then
            echo "dependencies=true" >> "$GITHUB_OUTPUT"
            dependencyList="\n$dependencyList"
            sed -i "s/<!-- DEPENDENCIES_PLACEHOLDER -->/$dependencyList/" "$template_file";
          else 
            sed -i 's/<!-- DEPENDENCIES_PLACEHOLDER -->/:white_check_mark: Keine Dependencies/' "$template_file";
          fi
          
          ## JUnit
          echo "JUnit setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- JUNIT_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Cucumber
          echo "Cucumber setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- CUCUMBER_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Coverage
          echo "Coverage setzen"
          sed -i 's/<!-- COVERAGE_PLACEHOLDER -->/${{ steps.fetch-coverage.outputs.coverage }}/' "$template_file";
          git push --tags -f

      - name: Release erstellen
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ steps.bump-semver.outputs.new_version }}.jar
          body_path: ".github/templates/release_template.md"
          token: ${{ env.TOKEN }}
          generate_release_notes: true
          tag_name: ${{ steps.bump-semver.outputs.new_version }}
          name: ${{ steps.bump-semver.outputs.new_version }}

      - name: Upload API Doc
        uses: ./mcbscore/github/actions/upload-api-doc-assets
        with:
          componentVersion: ${{ steps.bump-semver.outputs.new_version }}
          apiDocYmlPattern: ${{ env.API_DOC_YAML_PATTERN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_R_PACKAGES }}

      - name: Docker Image erzeugen
        uses: ./mcbscore/github/actions/create-microservice-docker-image
        with:
          componentName: ms-${{ env.COMPONENT }}
          componentVersion: ${{ steps.bump-semver.outputs.new_version }}
          jar: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ steps.bump-semver.outputs.new_version }}.jar
          javaVersion: ${{ env.JAVA_VERSION }}

      # Deployment Dev
      - name: Deployment Workflow inkl. k8s starten
        id: deployment
        uses: benc-uk/workflow-dispatch@v1.2.2
        with:
          workflow: Deployment
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "environment": "dev",
              "component": "${{ env.COMPONENT }}", 
              "componentVersion": "${{ steps.bump-semver.outputs.new_version }}"
            }

      - name: Developer Portal Upload starten
        id: developerPortalUpload
        if: hashFiles('.github/**/developerPortal.yml') != ''
        uses: benc-uk/workflow-dispatch@v1.2.2
        with:
          workflow: DeveloperPortal Upload
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "environment": "dev",
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ steps.bump-semver.outputs.new_version }}"
            }

      # Post Deployment Steps
      # @todo create an action for this
      - name: Check Deployment Workflow Status
        run: |
          # Set max checks and initialize counter
          MAX_CHECKS=30  # Number of checks before timeout, for 15 minutes total.
          COUNTER=0
          FOUND_RUN_ID=""
          INITIAL_SLEEP=60
          RETRY_SLEEP=30
          
          echo "Starting the Check Deployment Workflow Status..."
          sleep 60  # Sleep for 1 minute to allow workflow to register

          # Fetch the workflow runs
          echo "Fetching workflow runs for workflow ID: ${{ steps.deployment.outputs.workflowId }}"
          WORKFLOW_RUNS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                          "https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ steps.deployment.outputs.workflowId }}/runs")
          
          # Extract the ID and name of the latest run
          LATEST_RUN=$(echo "$WORKFLOW_RUNS" | jq '.workflow_runs[0]')  # Assuming the first run is the latest
          RUN_ID=$(echo "$LATEST_RUN" | jq -r '.id')
          RUN_NAME=$(echo "$LATEST_RUN" | jq -r '.name')
          
          echo "Checking run with ID: $RUN_ID and name: $RUN_NAME"
          
          # Loop to check the status of the identified run
          while true; do
            # Increase counter
            COUNTER=$(( COUNTER + 1 ))
            REMAINING_CHECKS=$(( MAX_CHECKS - COUNTER ))
            REMAINING_TIME=$(( REMAINING_CHECKS * RETRY_SLEEP / 60 ))  # Convert to minutes
          
            echo "Check attempt $COUNTER of $MAX_CHECKS. Remaining checks: $REMAINING_CHECKS. Time left before timeout: ~$REMAINING_TIME minutes."
          
            # Fetch the specific run details
            RUN_DETAILS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                                "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID")
          
            RUN_STATUS=$(echo "$RUN_DETAILS" | jq -r '.status')
            CONCLUSION=$(echo "$RUN_DETAILS" | jq -r '.conclusion')
          
            echo "Run Status: $RUN_STATUS, Conclusion: $CONCLUSION"
          
            # Check if the workflow is either queued or still running
            if [[ "$RUN_STATUS" == "queued" || "$RUN_STATUS" == "in_progress" || "$RUN_STATUS" == "null" ]]; then
              echo "Deployment Workflow is $RUN_STATUS..."
          
              if [[ "$COUNTER" -ge "$MAX_CHECKS" ]]; then
                echo "Timeout waiting for the Deployment Workflow."
                exit 1
              fi
          
              sleep $RETRY_SLEEP  # Wait for a specified duration before checking again
            else
              # If not queued or in progress, break the loop
              break
            fi
          done
          
          # Check the conclusion of the run
          if [[ "$CONCLUSION" == "null" || "$CONCLUSION" != "success" ]]; then
            echo "Deployment Workflow did not complete successfully. Conclusion: $CONCLUSION"
            exit 1
          else
            echo "Deployment Workflow completed with Conclusion: $CONCLUSION"
          fi

      - name: dbChanges Workflow starten
        if: hashFiles('.github/**/dbChanges.yml') != ''
        uses: benc-uk/workflow-dispatch@v1.2.2
        with:
          workflow: DB Changes
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ steps.bump-semver.outputs.new_version }}",
              "tagPrefix": "${{ env.TAG_PREFIX }}"
            }

      - name: Bambi Parameter setzen
        run: |
          BAMBI_ARGS="{ \
            \"renovate\": \"${{ steps.update_release_template.outputs.renovate }}\", \
            \"renovateInfo\": \"${{ steps.update_release_template.outputs.renovate_title }}\", \
            \"ibnDate\": \"${{ steps.update_release_template.outputs.epic_dueDate }}\", \
            \"changesInConfiguration\": \"${{ steps.update_release_template.outputs.ms_configuration }}\", \
            \"changesInDeployment\": \"${{ steps.update_release_template.outputs.ms_deployment }}\", \
            \"dbChanges\": \"${{ steps.update_release_template.outputs.db_changes }}\", \
            \"dependencies\": \"${{ steps.update_release_template.outputs.dependencies }}\" \
          }"
          echo "BAMBI_ARGS=$(echo "$BAMBI_ARGS" | sed 's/"/\\"/g')" >> $GITHUB_ENV

      - name: postBuild Workflow starten
        if: hashFiles('.github/**/cicd_postBuild.yml') != ''
        uses: benc-uk/workflow-dispatch@v1.2.2
        with:
          workflow: CICD PostBuild
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "releaseVersion": "${{ steps.bump-semver.outputs.new_version }}",
              "issueList": "${{ steps.update_release_template.outputs.issue_list }}",
              "bambiArgs": "${{ env.BAMBI_ARGS }}"
            }

      - name: SBOM zu DependencyTrack senden
        uses: DependencyTrack/gh-upload-sbom@v3.0.0
        with:
          protocol: ${{ env.DEPENDENCYTRACK_PROTOCOL }}
          serverHostname: ${{ env.DEPENDENCYTRACK_HOSTNAME }}
          port: ${{ env.DEPENDENCYTRACK_PORT }}
          apiKey: ${{ env.DEPENDENCYTRACK_API_KEY }}
          projectName: ${{ env.JIRA_COMPONENT }}
          projectVersion: ${{ steps.bump-semver.outputs.new_version }}
          bomFilename: ${{env.DEPENDENCYTRACK_BOM}}
          autoCreate: true
