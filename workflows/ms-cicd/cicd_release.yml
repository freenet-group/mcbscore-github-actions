#
# Generated by repo  / workflow Distribute from file workflows/ms/build.yml
#
# Generated by repo freenet-group/mcbscore-github-actions / workflow Distribute from file workflows/ms/build.yml
#
name: CICD Release

on:
  pull_request:
    types: [ closed ]
    branches:
      - 'develop'
  workflow_dispatch:
    inputs:
      release:
        description: 'Release wirklich erstellen?'
        required: true
        type: boolean

jobs:
  release:
    if: github.event.pull_request.merged == true || github.event.inputs.release == 'true'
    runs-on: [ self-hosted, k8s ]
    env:
      ACTIONS_REPOSITORY: freenet-group/mcbscore-github-actions
      ACTIONS_PATH: mcbscore/github
      KEY_SERVER: ${{ secrets.CERT_SERVER }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: AWS Secrets auslesen
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbs_user = USER,
            /github/secrets/mcbstest_credentials = MCBSTEST_CREDENTIALS,
            /github/secrets/mcbstest_jiracloud_credentials = MCBSTEST_JIRACLOUD_CREDENTIALS,
            /github/common/jira/jira_cloud_url = JIRA_CLOUD_URL,
            /github/secrets/dependencytrack_protocol = DEPENDENCYTRACK_PROTOCOL,
            /github/secrets/dependencytrack_hostname = DEPENDENCYTRACK_HOSTNAME,
            /github/secrets/dependencytrack_port = DEPENDENCYTRACK_PORT,
            /github/secrets/dependencytrack_api_key = DEPENDENCYTRACK_API_KEY

      - name: Read workflow.properties
        shell: bash
        run: |
          cat ./.github/workflow.properties >> $GITHUB_ENV

      - name: Checkout mcbscore-github-actions
        uses: actions/checkout@v3
        with:
          repository: ${{ env.ACTIONS_REPOSITORY }}
          token: ${{ env.TOKEN }}
          path: ${{ env.ACTIONS_PATH }}

      - name: Initialize Workflow
        uses: ./mcbscore/github/actions/init-workflow
        with:
          installJava: true
          installGithubCli: true
          installJq: true

      - name: Copy keystore-files
        if: env.KEY_SERVER != ''
        shell: bash
        run: |
          certServer='${{ env.KEY_SERVER }}'
          scp -p "${certServer}:oidc/keys/keystore.jwks" "${certServer}:oidc/keys/samlKeystore.jks" docker/home/oidc/keys/
          ls -l docker/home/oidc/keys

      - name: Gradle Build with CyclonedxBom (SBOM)
        uses: ./mcbscore/github/actions/gradle-build
        with:
          artifactoryUserName: ${{ secrets.MD_ARTIFACTORY_USER }}
          artifactoryPassword: ${{ secrets.MD_ARTIFACTORY_PW }}
          sonarqubeToken: ${{ secrets.SONARQUBE_TOKEN }}
          sonarqubeUrl: ${{ secrets.SONARQUBE_HOST_URL }}
          enableSonarCheckOnAllBranches: true
          gradleOptions: cyclonedxBom

      - name: Release Label einlesen
        id: release-label
        uses: actions-ecosystem/action-release-label@v1
        with:
          label_prefix: 'release:'

      - name: Letzten Release Tag holen
        id: get-latest-tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        with:
          initial_version: 0.0.0

      - name: Semver hochzählen
        id: bump-semver
        uses: actions-ecosystem/action-bump-semver@v1
        with:
          current_version: ${{ steps.get-latest-tag.outputs.tag  }}
          level: ${{ steps.release-label.outputs.level || 'patch' }}

      - name: Release Version in DB Changes eintragen
        if: hashFiles('.github/**/dbChanges.yml') != ''
        shell: bash
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          find ./${{ env.DB_CHANGES_DIRECTORY }} -type f -exec sed -i 's/{releaseVersion}/${{ steps.bump-semver.outputs.new_version }}/g' {} +
          changesDetected=`git status --porcelain`
          if [ -n "$changesDetected" ]
          then
            echo "Committing changes"
            git commit -am "Release Version in DB Changes eingetragen"
            git push
          fi
          git tag -f -a sql-${{ env.TAG_PREFIX }}${{ steps.bump-semver.outputs.new_version }} -m "tagging sql-${{ env.TAG_PREFIX }}${{ steps.bump-semver.outputs.new_version }}"

      # @todo Error: Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 - https://github.com/freenet-group/ms-cicd/actions/runs/5175184623/jobs/9322449410#step:17:118
      #      - name: Sonar-Coverage abholen
      #        id: fetch-coverage
      #        if: ${{ (env.JAVA_VERSION != '8') && (env.COVERAGE_APP != '') }}
      #        uses: ./mcbscore/github/actions/sonar-check
      #        with:
      #          sonarUrl: ${{ env.SONAR_API_URL }}
      #          sonarCredentials: ${{ env.MCBSTEST_CREDENTIALS }}
      #          projectKeyPath: ${{ env.COVERAGE_PATH }}
      #          projectKeyName: ${{ env.COVERAGE_APP }}
      #          atlassianToolsVersion: ${{ env.ATLASSIAN_DEVELOPER_TOOLS_VERSION }}
      #
      #      - name: Sonar-Coverage prüfen
      #        if: ${{ (env.JAVA_VERSION != '8') && (env.COVERAGE_APP != '') && (steps.fetch-coverage.outputs.coverage < env.COVERAGE_LIMIT) && (env.COVERAGE_FAIL == 'TRUE') }}
      #        uses: ./mcbscore/github/actions/create-sonar-issue
      #        with:
      #          jiraUrl: ${{ env.JIRA_CLOUD_URL }}
      #          jiraCredentials: ${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }}
      #          jiraProject: ${{ env.JIRA_PROJECT }}
      #          component: ${{ env.JIRA_COMPONENT }}
      #          componentVersion: ${{ steps.bump-semver.outputs.new_version }}
      #          coverageLimit: ${{ env.COVERAGE_LIMIT }}
      #          coverage: ${{ steps.fetch-coverage.outputs.coverage }}
      #          atlassianToolsVersion: ${{ env.ATLASSIAN_DEVELOPER_TOOLS_VERSION }}

      - name: Tag einchecken
        uses: actions-ecosystem/action-push-tag@v1
        with:
          tag: ${{ steps.bump-semver.outputs.new_version }}
          message: '${{ steps.bump-semver.outputs.new_version }}: PR #${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}'

      - name: Issue-List Alternative erzeugen
        id: jira_keys
        uses: varnerknut/jira-extract-issue-keys-from-tags@1.2
        with:
          token: ${{ env.TOKEN }}
          head-tag: ${{ steps.bump-semver.outputs.new_version }}

      - name: Release-Template ausfüllen
        id: update_release_template
        run: |
          template_file=".github/actions/create-release-note/templates/release_template.md"
          uniqueIssueList=$(echo "${{ steps.jira_keys.outputs.issue-keys }}" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')
          issueList=""
          issueListLines=""
          linkIssuesListLines=""
          allComponentList=""
          dependencyList=""
          linkedIssuesListLines=""

          # Prüfen ob das label "renovate" gesetzt wurde
          PR_NUMBER=$(jq -r ".pull_request.number" "$GITHUB_EVENT_PATH")
          LABELS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/labels" | jq -r ".[].name")
          if echo "$LABELS" | grep -q "renovate"; then
            if [ -z "$uniqueIssueList" ]; then
              uniqueIssueList="ABRMS-5265"
            else
              uniqueIssueList+=",ABRMS-5265"
            fi
          fi
          
          # IssueList / Implemented Issues
          echo "issue_list=$uniqueIssueList" >> "$GITHUB_OUTPUT"
          echo "Folgende Issues werden analysiert $uniqueIssueList"
          IFS=',' read -ra issues <<< "$uniqueIssueList"
          for line in "${issues[@]}"; do
            # Tabellen Eintrag erstellen
            issueNumber=$(echo "$line" | cut -d";" -f1 | xargs)
            echo "$issueNumber wird eingelesen"
    
            # Renovate Ticket überspringen, Rest aber prüfen
            if [ "$issueNumber" = "ABRMS-5265" ]; then
              title="${{ github.event.pull_request.title }}"
              issueListLines+="| ABRMS-5265 | $title | Renovate | Renovate |\n"
              echo "renovate=true" >> "$GITHUB_OUTPUT"
              continue  # Rest überspringen
            fi
          
            # Jira Ticket einlesen
            echo "Jira API wird zu $issueNumber befragt"
            API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$issueNumber"
            BASIC_AUTH=$(echo -n ${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }} | base64 -w0)
            AUTH_HEADER="Authorization: Basic $BASIC_AUTH"
            issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")
          
            # Titel einlesen
            echo "Titel zu $issueNumber extrahieren"
            title=$(echo "$issue_info" | jq -r '.fields.summary')
          
            # Labels einlesen
            echo "Labels zu $issueNumber extrahieren"
            labels=$(echo "$issue_info" | jq -r '.fields.labels[]' | paste -sd ", ")
          
            # Komponenten extrahieren
            echo "Komponenten zu $issueNumber extrahieren"
            componentList=$(echo "$issue_info" | jq -r '.fields.components[].name' | paste -sd ", ")
            allComponentList+=$componentList
          
            # Dependencies extrahieren
            echo "Dependencies zu $issueNumber extrahieren"
            dependencyList+="\t * :warning: $issueNumber: $(echo "$issue_info" | jq -r '.fields.customfield_10686')\n"

            # Ticket Tabelle ausfüllen
            echo "Tabelleneintrag zum Ticket $issueNumber wird erstellt"
            issueListLines+="| $issueNumber | $title | $labels | $componentList |\n"
          
            # Verknüpfte Tickets
            echo "Verknüpfte Tickets zu $issueNumber einlesen und Tabelle befüllen"
            for k in $(jq '.fields.issuelinks | keys | .[]' <<<"$issue_info"); do
              linkedIssue=$(jq -r ".fields.issuelinks[$k]" <<<"$issue_info");
          
              # Prüfe auf ausgehende Links
              isOutward=$(jq 'has("outwardIssue")' <<<"$linkedIssue")
              if $isOutward; then
                linkedRelation=$(jq -r '.type.outward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.outwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.outwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.outwardIssue.fields.status.name' <<<"$linkedIssue")
              else
                linkedRelation=$(jq -r '.type.inward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.inwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.inwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.inwardIssue.fields.status.name' <<<"$linkedIssue")
              fi
                linkedIssuesListLines+="| $linkedIssueNumber | $linkedSummary | $linkedStatus | $linkedRelation |\n"
          
                echo "Verknüpftes Ticket erkannt: $linkedIssueNumber - $linkedSummary"
            done
          done
          
          # Platzhalter austauschen
          echo "Platzhalter im Template austauschen"
          
          ## Tabellen
          echo "IssueList setzen"
          echo "$issueListLines"
          sed -i "s#<!-- IMPLEMENTED_ISSUES_PLACEHOLDER -->#$issueListLines#" "$template_file"
          echo "Verlinkte Tickets setzen"
          echo "$linkedIssuesListLines"
          sed -i "s/<!-- IMPLEMENTED_LINKED_ISSUES_PLACEHOLDER -->/$linkedIssuesListLines/" "$template_file"
          
          ## EPIC
          echo "EPIC setzen"
          if [ "${{ github.event.inputs.epic }}" = "META-170" ]; then
            sed -i 's/<!-- EPIC_PLACEHOLDER -->/[x] keine umfassendes Epic"' "$template_file";
          else
            sed -i 's/<!-- EPIC_PLACEHOLDER -->/${{ github.event.inputs.epic }}/' "$template_file";
          fi
          
          ## Java
          echo "Java setzen"
          sed -i 's/<!-- JAVA_VERSION_PLACEHOLDER -->/${{ env.RELEASENOTES_JAVA_RELEASE }}/' "$template_file";
          
          ## MS-Configuration
          echo "MS-Configuration Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-configuration"; then
            url="${{ github.SERVER_URL }}/ms-configuration"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:warning: Achtung [MS-Configuration]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_CONFIGURATION_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## MS-Deployment
          echo "MS-Deployment Flag setzen"
          if echo "$allComponentList" | grep -iq "ms-deployment"; then
            url="${{ github.SERVER_URL }}/ms-deployment"
            escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
            sed -i "s/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:warning: Achtung [MS-Deployment]($escaped_url) wurde geändert/" "$template_file";
          else
            sed -i 's/<!-- MS_DEPLOYMENT_PLACEHOLDER -->/:white_check_mark: Keine Änderung/' "$template_file";
          fi
          
          ## DB-Changes
          echo "DB-Changes Flag setzen"
          if echo "$allComponentList" | grep -iq "sql update script"; then
            sed -i "s/<!-- DB_CHANGES_PLACEHOLDER -->/:warning: Achtung DB-Changes sind notwendig/" "$template_file";
          else 
            sed -i 's/<!-- DB_CHANGES_PLACEHOLDER -->/:white_check_mark: Keine DB-Changes/' "$template_file";
          fi
          
          ## Dependencies
          echo "Dependencies setzen"
          if [ -z "$dependencyList" ]; then
            sed -i "s/<!-- DEPENDENCIES_PLACEHOLDER -->/$dependencyList/" "$template_file";
          else 
            sed -i 's/<!-- DEPENDENCIES_PLACEHOLDER -->/:white_check_mark: Keine Dependencies/' "$template_file";
          fi
          
          ## JUnit
          echo "JUnit setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- JUNIT_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Cucumber
          echo "Cucumber setzen"
          url="${{ github.SERVER_URL }}/${{ github.REPOSITORY }}/releases/"
          escaped_url=$(sed 's/[\/&]/\\&/g' <<< "$url")
          sed -i "s/<!-- CUCUMBER_RESULT_PLACEHOLDER -->/$escaped_url/" "$template_file"
          
          ## Coverage
          echo "Coverage setzen"
          sed -i 's/<!-- COVERAGE_PLACEHOLDER -->/${{ steps.fetch-coverage.outputs.coverage }}/' "$template_file";
          git push --tags -f

      - name: Release erstellen
        uses: softprops/action-gh-release@v1
        with:
          files: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}.jar
          body_path: ".github/actions/create-release-note/templates/release_template.md"
          token: ${{ env.TOKEN }}
          generate_release_notes: true
          tag_name: ${{ steps.bump-semver.outputs.new_version }}
          name: ${{ steps.bump-semver.outputs.new_version }}

      - name: Upload API Doc
        uses: ./mcbscore/github/actions/upload-api-doc-assets
        with:
          componentVersion: ${{ steps.bump-semver.outputs.new_version }}
          apiDocYmlPattern: ${{ env.API_DOC_YAML_PATTERN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_R_PACKAGES }}

      - name: Docker Image erzeugen
        uses: ./mcbscore/github/actions/create-microservice-docker-image
        with:
          componentName: ms-${{ env.COMPONENT }}
          componentVersion: ${{ steps.bump-semver.outputs.new_version }}
          jar: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}.jar
          javaVersion: ${{ env.JAVA_VERSION }}

      - name: dbChanges Workflow starten
        if: hashFiles('.github/**/dbChanges.yml') != ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: DB Changes
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ steps.bump-semver.outputs.new_version }}",
              "tagPrefix": "${{ env.TAG_PREFIX }}"
            }

      - name: postBuild Workflow starten
        if: hashFiles('.github/**/cicd_postBuild.yml') != ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: CICD PostBuild
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "releaseVersion": "${{ steps.bump-semver.outputs.new_version }}",
              "issueList": "${{ steps.update_release_template.outputs.issue_list }}"
            }

      - name: SBOM zu DependencyTrack senden
        uses: freenet-actions/gh-upload-sbom@1.1.2
        with:
          protocol: ${{ env.DEPENDENCYTRACK_PROTOCOL }}
          serverHostname: ${{ env.DEPENDENCYTRACK_HOSTNAME }}
          port: ${{ env.DEPENDENCYTRACK_PORT }}
          apiKey: ${{ env.DEPENDENCYTRACK_API_KEY }}
          projectName: ${{ env.JIRA_COMPONENT }}
          projectVersion: ${{ steps.bump-semver.outputs.new_version }}
          bomFilename: ${{env.DEPENDENCYTRACK_BOM}}
          autoCreate: true