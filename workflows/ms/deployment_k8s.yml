name: K8s Deployment
#Name fuer den workflow. Wichtig bei mehreren workflows im selben Repository um die workflows im actions-tab unterscheiden zu koennen.
run-name: K8s ${{ github.event.inputs.environment }} Deployment ${{ github.event.inputs.component }} ${{ github.event.inputs.componentVersion }} dry=${{ github.event.inputs.dryRun }}

on:
  workflow_dispatch:
    inputs:
      component:
        description: Der Name der Komponente
        required: true
      componentVersion:
        description: Die Version der Komponente
        required: true
      environment:
        description: Die Zielumgebung
        required: true
      timeout:
        description: Zeit, nach der das Helm Deployment zurückgerollt wird, wenn noch nicht erfolgreich
        required: false
        default: 10m0s
      deploymentRepositoryBranch:
        description: Branch von Repository ms-deployment, der benutzt werden soll
        required: false
        default: main
      maxWaitForDeployment:
        description: maximale Zeit, die beim Helm-Statusscheck auf ein Deployment gewartet wird
        required: true
        default: 11m0s
      dryRun:
        type: boolean
        description: Nicht deployen, nur Helm Chart Ergebnis anzeigen (helm --dry-run)
        required: false
        default: false

#Nur ein k8s Workflow darf gleichzeitg gestartet werden. Alle weitere k8s bleiben in pending bis der vorherige Workflow abgeschlossen sind.
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.component }}-${{ github.event.inputs.dryRun }}
  cancel-in-progress: false
env:
  DEPLOYMENT_PATH: mcbscore/deployment
  JAVA_VERSION: 11
  GENERATED_SSH_KEY_FILE: id_rsa
  KEY_SERVER: ${{ secrets.CERT_SERVER }}

jobs:
  build-matrix:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Read AWS Secrets
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = GITHUB_TOKEN

      # Auschecken des Deployment Repositories
      - name: Checkout Deployment Data / Scripts
        uses: actions/checkout@v3
        with:
          repository: freenet-group/ms-deployment
          token: ${{ env.GITHUB_TOKEN }}
          path: ${{ env.DEPLOYMENT_PATH }}
          ref: ${{ github.event.inputs.deploymentRepositoryBranch }}

      # Java installieren (für jrunscript in ms_properties_to_json.sh)
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: zulu
          # eine Version mit jrunscript
          java-version: ${{ env.JAVA_VERSION }}

      # jq installieren
      - name: Setup jq
        uses: freenet-actions/setup-jq@v2

      # Github Job-Matrix entsprechend domains aus kubernetes-deployment*.json oder deployment*.properties initialisieren
      - name: Init Job Matrix
        id: set-matrix
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'
          domains=

          for f in \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment-${environment}.json" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment.json" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/deployment-${environment}.json" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/deployment-${environment}.properties" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/deployment.properties"
          do
            if [ -z "$domains" -a -e "$f" ]; then
              echo "Prüfe domains in $f"
              domains=$(
                if [[ "$f" == *.json ]]; then
                  cat -- "$f"
                else
                  ./${{ env.DEPLOYMENT_PATH }}/scripts/common/properties_to_json.sh < "$f"
                fi \
                | jq -c -r 'if .domains != null then (.domains | split("\\s+"; "")) else "" end'
                # ^ ohne Domains: Leerstring => jq -r gibt nichts aus => if [ -z "$domains" ] bleibt true.
                # mit Domains: jq split Ergebnis ist Array (z.B. ["km","mc"]); jq ignoriert -r.
              )
            fi
          done
          printf 'domains: %s\n' "$domains"

          # Ergebnis: domains JSON Array wie ["km","mc"] oder Default ["-"]
          echo "domainMatrix=${domains:-[\"-\"]}" >> $GITHUB_OUTPUT

      # Prüft, ob deployed werden soll
      - name: Check for deployment
        id: deployment-check
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'

          enabled=$(
            for f in \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment.json" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment-${environment}.json"
            do
              printf '%s existiert' "$f" >&2
              if [ -e "$f" ]; then echo >&2; cat -- "$f"; else echo ' nicht' >&2; fi
            done | jq -s -r 'add | .enabled'
          )

          echo "deploymentEnabled=$enabled" >> $GITHUB_OUTPUT

    outputs:
      deployment-enabled: ${{ steps.deployment-check.outputs.deploymentEnabled }}
      domain-matrix: ${{ steps.set-matrix.outputs.domainMatrix }}

  helm-deployment:
    needs: build-matrix
    if: ${{ needs.build-matrix.outputs.deployment-enabled == 'true' }}
    runs-on: [self-hosted, vm]
    container:
      image: docker.mobilcom.de/dpvo/cicd-kubernetes-helm3:latest
    strategy:
      fail-fast: false
      matrix:
        domain: ${{ fromJson(needs.build-matrix.outputs.domain-matrix) }}
    steps:
      # Leeren Workspace sicherstellen
      - name: Ensure clean workspace
        run: |
          echo "Cleaning up previous run"
          chown -R "$(id -u):$(id -g)" . || true
          rm -rf *

      - name: Clean
        uses: AutoModality/action-clean@v1.1.0

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Read AWS Secrets
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = GITHUB_TOKEN,
            /github/secrets/ssh/mdmcbsapi-app/zxrestapi_ppk = SSH_KEY

      # Auschecken des Deployment Repositories
      - name: Checkout Deployment Data / Scripts
        uses: actions/checkout@v3
        with:
          repository: freenet-group/ms-deployment
          token: ${{ env.GITHUB_TOKEN }}
          path: ${{ env.DEPLOYMENT_PATH }}
          ref: ${{ github.event.inputs.deploymentRepositoryBranch }}

      # jq installieren
      - name: Setup jq
        uses: freenet-actions/setup-jq@v2

      # Installationen: unzip wird fuer Kubernetes Login Step benötigt; ssh für das scp der Keystore Dateien
      - name: Install unzip, scp
        shell: bash
        run: |
          apt-get update
          apt-get install --yes unzip
          if [ -n "$KEY_SERVER" ]; then
            apt-get install --yes ssh
          fi

      # ssh Konfig
      - name: Setup ssh
        if: env.SSH_KEY != ''
        shell: bash
        run: |
          printf '' > "$GENERATED_SSH_KEY_FILE"
          chmod 600 -- "$GENERATED_SSH_KEY_FILE"
          printf %s "$SSH_KEY" >> "$GENERATED_SSH_KEY_FILE"
          ls -lAF -- "$GENERATED_SSH_KEY_FILE"

      # Keystore-Dateien herunterladen
      # Werden vom Workflow selbst nicht gebraucht, aber evtl per kubernetes-deployment*.json als
      # Quelle von "sourceType": "FILE" Secrets.
      - name: Copy keystore files
        if: env.KEY_SERVER != ''
        shell: bash
        run: |
          certServer='${{ secrets.CERT_SERVER }}'
          if scp -i "$GENERATED_SSH_KEY_FILE" -o StrictHostKeyChecking=no -p \
              "${certServer}:oidc/keys/keystore.jwks" "${certServer}:oidc/keys/samlKeystore.jks" \
              docker/home/oidc/keys/; then
            ls -lA docker/home/oidc/keys
          else
            echo 'Keine Keystore-Dateien kopiert (aber vielleicht ja gar nicht gefordert)'
          fi

      # kubernetes-deployment JSON einlesen
      - name: Read kubernetes-deployment.json
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'

          # Das letzte JSON-Objekt (Datei mit -${environment}) gewinnt in jq add.
          {
            printf '{ "secrets": [] }\n'  # Default hier beimischen ist einfacher als immer auch ohne "secrets" auszukommen.
            for f in "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment.json" "./${{ env.DEPLOYMENT_PATH }}/properties/${component}/kubernetes-deployment-${environment}.json"; do
              printf '%s existiert' "$f" >&2
              if [ -e "$f" ]; then echo >&2; cat -- "$f"; else echo ' nicht' >&2; fi
            done \
          } | jq -s add | tee kubernetes-deployment.generated.json

      # kubernetes-deployment JSON auswerten
      - name: Process kubernetes-deployment.generated.json
        shell: bash
        run: |
          # Umgebungsvariablen setzen
          jq -r '
              "K8S_CLUSTER="        + (.cluster       // ("cluster fehlt"       | halt_error)) + "\n" +
              "K8S_ENVIRONMENT="    + (.environment   // ("environment fehlt"   | halt_error)) + "\n" +
              "K8S_NAMESPACE="      + (.namespace     // ("namespace fehlt"     | halt_error)) + "\n" +
              "K8S_COMPONENT_NAME=" + (.componentName // ("componentName fehlt" | halt_error)) + "\n" +
              "HELM_CHART="         + (.helmChart     // ms)                                   + "\n" +
              ""' \
            < kubernetes-deployment.generated.json \
          | tee -a -- "$GITHUB_ENV"

          # parameterPairs für aws-ssm-getparameters-action ermitteln aus .secrets in kubernetes-deployment.generated.json
          # Beispiel:
          # kubernetes-deployment.generated.json enthält:
          # {
          # 	...
          # 	"secrets": [
          # 		{
          # 			"sourceType": "AWS_PARAMETER",
          # 			"source": "/config/ms/homer/homer.prince.license",
          # 			"targetType": "FILE",
          # 			"target": "/usr/lib/prince/license/license.dat"
          # 		},
          # 		{
          # 			"sourceType": "AWS_PARAMETER",
          # 			"source": "/config/ms/application/test",
          # 			"targetType": "ENV",
          # 			"target": "TEST_VAR",
          # 			"conversion": "b64enc"
          # 		},
          # 		{
          # 			"sourceType": "SOMETHING_UNSUPPORTED",
          # 			"source": "...",
          # 			"targetType": "...",
          # 			"target": "..."
          # 		}
          # 	]
          # }
          # => jq Ergebnis:
          #   /config/ms/homer/homer.prince.license=AWS_DYNAMIC_PARAM_NAME1,
          #   /config/ms/application/test=AWS_DYNAMIC_PARAM_NAME2,
          paramPairs=$(jq -r '
              [ .secrets[] | select(.sourceType == "AWS_PARAMETER") ]
              | foreach .[] as $x (0; . + 1; "\($x.source)=AWS_DYNAMIC_PARAM_NAME\(.),")' \
            < kubernetes-deployment.generated.json)

          # Als (mehrzeilige) Umgebungsvariable DYNAMIC_AWS_PARAM_PAIRS setzen:
          printf 'DYNAMIC_AWS_PARAM_PAIRS<<...snip...\n%s\n...snip...\n' "$paramPairs" \
          | tee -a -- "$GITHUB_ENV"

      # Secrets für K8S Deployment aus AWS auslesen
      - name: Read AWS Parameters for K8S Deployment
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            ${{ env.DYNAMIC_AWS_PARAM_PAIRS }}
            /kubernetes/${{ env.K8S_ENVIRONMENT }}/namespace/${{ env.K8S_NAMESPACE }}/k8s-token = K8S_TOKEN,
            /kubernetes/github-packages/token = K8S_REGISTRY,
            /github/secrets/jasypt_encryptor_password = JASYPT_ENCRYPTOR_PASSWORD

      # AWS Secrets aus Umgebungsvariablen in JSON für Helm umwandeln
      - name: AWS Parameters to Helm JSON
        shell: bash
        run: |
          # Beispiel (Fortsetzung): aws-ssm-getparameters-action hat dann Umgebungsvariablen gesetzt:
          # - DYNAMIC_AWS_PARAM_PAIRS1 mit dem Wert X für "/config/ms/homer/homer.prince.license",
          # - DYNAMIC_AWS_PARAM_PAIRS2 mit dem Wert Y für "/config/ms/application/test".
          # Daraus machen wir jetzt kubernetes-secrets-aws.generated.json in dem im Helm Chart erwarteten Format:
          # {
          # 	"secrets": [
          # 		{
          # 			"type": "FILE"
          # 			"key": "/usr/lib/prince/license/license.dat",
          # 			"value": "X"
          # 		},
          # 		{
          # 			"type": "ENV",
          # 			"key": "TEST_VAR",
          # 			"value": "Y",
          # 			"conversion": "b64enc"
          # 		}
          # 	]
          # }
          jq '
              [
                [.secrets[] | select(.sourceType == "AWS_PARAMETER")]
                | foreach .[] as $x (
                    0;
                    . + 1;
                    {
                      "type": $x.targetType,
                      "key": $x.target,
                      "value": env["AWS_DYNAMIC_PARAM_NAME\(.)"],
                      "MISSING_AWS_DYNAMIC_PARAM_NAME": (if env["AWS_DYNAMIC_PARAM_NAME\(.)"] == null then $x.source else null end),
                      "conversion": $x.conversion
                    }
                  )
                | with_entries(select(.value != null))
              ]
              | { "secrets": . }' \
          < kubernetes-deployment.generated.json \
          > kubernetes-secrets-aws-all.generated.json
          # ^ Das ".value" in with_entries(select(.value != null)) ist nicht der "value" Key, sondern bei with_entries
          # der jeweilige JSON Value! Damit unterdrücken wir neben "value": null Einträgen z.B. auch "conversion": null.

          # Der Fall "value" == null (d.h. env["AWS_DYNAMIC_PARAM_NAME<n>"] null, d.h. Param-Name $x.source nicht im AWS
          # gefunden, kommt jetzt: Warnen und in Endergebnis kubernetes-secrets-aws.generated.json weglassen:
          missingParams=$(jq -r '[.secrets[].MISSING_AWS_DYNAMIC_PARAM_NAME | select(. != null)] | join(", ")' < kubernetes-secrets-aws-all.generated.json)
          if [ -n "$missingParams" ]; then printf '::warning::Nicht im AWS ParameterStore gefunden: %s\n' "$missingParams" >&2; fi
          jq '[.secrets[] | select(.value != null)] | { "secrets": . }' \
          < kubernetes-secrets-aws-all.generated.json \
          | tee kubernetes-secrets-aws.generated.json

      # Secrets in Dateien in JSON für Helm umwandeln
      - name: Secret files to Helm JSON
        shell: bash
        run: |
          # secretFiles := bash Array der .source Werte wo .sourceType == "FILE"
          # command substitution $(…) und eval separat, um ggf jq Fehlerstatus zu beachten
          secretFiles=$(jq --raw-output '.secrets[] | select(.sourceType == "FILE") | .source | @sh' < kubernetes-deployment.generated.json)
          eval "secretFiles=( $secretFiles )"

          # Inhalte der geheimen Dateien Base64-kodiert, Space-separiert
          secretFilesB64Data=''
          for ((i=0;i<${#secretFiles[@]};i++)) do
            secretFile=${secretFiles[i]}
            if [ ! -e "$secretFile" ]; then
              echo "Datei $secretFile existiert nicht. Bitte Step 'Copy keystore files' prüfen." >&2
              exit 2
            fi

            b64Data=$(base64 --wrap=0 < "$secretFile")

            # im Log maskieren [https://www.aaron-powell.com/posts/2022-07-14-working-with-add-mask-and-github-actions/]
            printf '::add-mask::%s\n' "$b64Data"

            printf '[%s] <%d Zeichen Base64 aus %s>\n' $i ${#b64Data} "$secretFile" >&2
            secretFilesB64Data=${secretFilesB64Data}${secretFilesB64Data:+ }${b64Data}
          done

          # analog AWS: konfigurierte { "sourceType": …, "source": …, "targetType": …, "target": … } Objekte auf
          # vom Helm Chart erwartete { "type": …, "key: …, "value: …, "conversion: … } mappen
          jq --arg secretFilesB64Data "$secretFilesB64Data" '
              ($secretFilesB64Data | split(" ")) as $secretFilesB64DataArray
              | [
                [.secrets[] | select(.sourceType == "FILE")]
                | foreach .[] as $x (
                    -1;
                    . + 1;
                    { "type": $x.targetType, "key": $x.target, "value": $secretFilesB64DataArray[.], "conversion": "b64dec" }
                  )
              ]
              | { "secrets": . }' \
          < kubernetes-deployment.generated.json \
          | tee >(jq '.secrets = (.secrets | map(.value = "… length " + (.value | length | tostring)))') \
          > kubernetes-secrets-files.generated.json
          # ↑ tee >(jq …): Debug-Ausgabe mit maskierten .secrets.value, aber aussagekräftiger als
          # ganz maskiert durch add-mask

      # kubernetes-secrets.generated.json := kubernetes-secrets-files.generated.json + kubernetes-secrets-aws.generated.json
      - name: Merge generated Helm JSON Secret files
        shell: bash
        run: |
          cat kubernetes-secrets-files.generated.json kubernetes-secrets-aws.generated.json \
          | jq '.secrets[]' | jq --slurp '{ "secrets": . }' \
          | tee >(jq '.secrets = (.secrets | map(.value = "… length " + (.value | length | tostring)))') \
          > kubernetes-secrets.generated.json
          # ↑ tee >(jq …): Debug-Ausgabe mit maskierten .secrets.value, aber aussagekräftiger als
          # ganz maskiert durch add-mask

      # Kubernetes Login
      - name: 'Login k8s/helm'
        uses: freenet-actions/prepare-k8s-env@v1
        with:
         k8s-host-url: 'https://${{ env.K8S_CLUSTER }}'
         k8s-token: ${{ env.K8S_TOKEN }}

      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: zulu
          java-version: ${{ env.JAVA_VERSION }}

      # deployment.json aus deployment*.properties generieren
      - name: Deployment Properties to JSON
        shell: bash
        run: |
          ./${{ env.DEPLOYMENT_PATH }}/scripts/microservice/ms_properties_to_json.sh '${{ github.event.inputs.component }}' '${{ github.event.inputs.environment }}' \
          | tee deployment.generated.json

      - name: Helm Deployment
        shell: bash
        run: |
          domain='${{ matrix.domain }}'
          component='${{ github.event.inputs.component }}'
          componentVersion='${{ github.event.inputs.componentVersion }}'
          environment='${{ github.event.inputs.environment }}'
          timeout='${{ github.event.inputs.timeout }}'
          dryRun=${{ github.event.inputs.dryRun }}
          # Github run id welche als label zur Identifikation in k8s gesetzt wird.
          runId='${{ github.run_id }}'

          helmOpts=()
          if $dryRun; then helmOpts=(--dry-run); fi

          # von Domain abhängige Helm Optionen
          if [ "$domain" = '-' ]; then
            name=$K8S_COMPONENT_NAME
            helmOpts=( "${helmOpts[@]}" "--set=hostname=${component}-${environment}" )
          # bei domain in component (z.B. component=oidc-km) den domain-Anteil entfernen,
          # um Doppelung wie "oidc-km-km" zu vermeiden
          else
            name=${K8S_COMPONENT_NAME}-${domain}
            helmOpts=(
              "${helmOpts[@]}"
              "--set=domain=$domain"
              "--set=hostname=${component%-$domain}-${domain}-${environment}"
            )
          fi
          
          chartDir="${{ env.DEPLOYMENT_PATH }}/helm/$HELM_CHART"

          # --values Helm Optionen
          # Die letzte Datei gewinnt in helm --values.
          for f in \
              deployment.generated.json \
              "$chartDir/stages/${environment}.yaml" \
              kubernetes-deployment.generated.json \
              kubernetes-secrets.generated.json
          do
            if [ -e "$f" ]; then
              helmOpts=("${helmOpts[@]}" "--values=$f")
            fi
          done

          # vor dem Deployment helm status --namespace="$K8S_NAMESPACE" "$K8S_COMPONENT_NAME" 
          # in einer Schleife (10s warten, insgesamt max. maxWaitForDeployment) prüfen
          maxWait='${{ github.event.inputs.maxWaitForDeployment }}'
          maxWait=${maxWait//h/hour}; maxWait=${maxWait//m/min}; maxWait=${maxWait//s/sec}
          maxWaitTimestamp=$(date -d "now +$maxWait" +%s)
          helmExit=0
          if  helm list --namespace="$K8S_NAMESPACE" | cut -d ' ' -f 1 | grep -Fxq -- "$K8S_COMPONENT_NAME"; then
              while [ "$(date +%s)" -lt "$maxWaitTimestamp" ]; do
                  helmStatus=$(helm status --output=json --namespace="$K8S_NAMESPACE" "$K8S_COMPONENT_NAME" | jq -r .info.status)
                  if  [[ "${helmStatus#pending}" != "$helmStatus" ]]; then
                      echo "Helm Status von $K8S_COMPONENT_NAME: $helmStatus, warte $waitPeriod s ..."
                      sleep 10
                      helmExit=1
                  else
                      echo "Helm Status von $K8S_COMPONENT_NAME: $helmStatus, starte Deployment ..."
                      maxWaitTimestamp=$(date -d "now" +%s)
                      helmExit=0
                  fi
              done
              if [ $helmExit -eq 1 ]; then
                  echo "Wartezeit überschritten, breche ab..."
                  exit 1
              fi
          fi

          # helm Befehl ausgeben, damit man ihn bei Fehler leicht nochmal manuell wiederholen kann
          # (ohne weiter Github Actions Spam zu senden). Secrets im Log sollte Github ja automatisch
          # unkenntlich machen.
          set -x

          # --set="environment=$environment": Wert aus Workflow Parameter (z.B. "dev") hat Vorrang
          # vor dem environment (z.B. "np"), das wir für den AWS Parameternamen in
          # kubernetes-deployment*.json haben.
          helm upgrade --namespace="$K8S_NAMESPACE" \
            --install --atomic --timeout="$timeout" \
            "$name" "$chartDir" \
            "${helmOpts[@]}" \
            --set="environment=$environment" \
            --set="appName=$K8S_COMPONENT_NAME" \
            --set="docker_config_base64=$K8S_REGISTRY" \
            --set='aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --set='aws_secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --set="jasypt_password=$JASYPT_ENCRYPTOR_PASSWORD" \
            --set="version=$componentVersion" \
            --set="runId='$runId'"

      - name: Cleanup
        if: ${{ always() }}
        run: |
          set +e
          rm -rfv -- docker/home/oidc/keys *.generated.json
          rm -rf /__w/_tool/*
