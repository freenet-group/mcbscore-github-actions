name: K8s Deployment

on:
  workflow_dispatch:
    inputs:
      component:
        description: 'Der Name der Komponente'
        required: true
      componentVersion:
        description: 'Die Version der Komponente'
        required: true
      environment:
        description: 'Die Zielumgebung'
        required: true
      timeout:
        description: Zeit, nach der das Helm Deployment zurückgerollt wird, wenn noch nicht erfolgreich
        required: false
        default: 10m0s
      deploymentRepositoryBranch:
        description: Branch von Repository ms-deployment, der benutzt werden soll
        required: false
        default: main
      maxWaitForDeployment:
        description: maximale Zeit, die beim Helm-Statusscheck auf ein Deployment gewartet wird
        required: true
        default: 11m0s
      dryRun:
        type: boolean
        description: Nicht deployen, nur Helm Chart Ergebnis anzeigen (helm --dry-run)
        required: false
        default: false

jobs:
  build-matrix:
    runs-on: ubuntu-latest
    steps:
      # Secrets aus AWS auslesen
      - name: Read and set AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: 'eu-central-1'

      - name: Read AWS Parameters
        uses: dkershner6/aws-ssm-getparameters-action@v1
        with:
          parameterPairs: |
            /github/secrets/mcbs_token = GITHUB_TOKEN

      # Auschecken des Deployment Repositories
      - name: Checkout Deployment Data / Scripts
        uses: actions/checkout@v3
        with:
          repository: freenet-group/ms-deployment
          token: ${{ env.GITHUB_TOKEN }}
          ref: ${{ github.event.inputs.deploymentRepositoryBranch }}

      # Java installieren (für jrunscript in ms_properties_to_json.sh)
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: zulu
          # eine Version mit jrunscript
          java-version: 11

      # jq installieren
      - name: Setup jq
        uses: freenet-actions/setup-jq@v1

      # Github Job-Matrix entsprechend domains aus kubernetes-deployment*.json oder deployment*.properties initialisieren
      - name: Init Job Matrix
        id: set-matrix
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'
          domains=

          for f in \
              "./properties/${component}/kubernetes-deployment-${environment}.json" \
              "./properties/${component}/kubernetes-deployment.json" \
              "./properties/${component}/deployment-${environment}.json" \
              "./properties/${component}/deployment-${environment}.properties" \
              "./properties/${component}/deployment.properties"
          do
            if [ -z "$domains" -a -e "$f" ]; then
              echo "Prüfe domains in $f"
              domains=$(
                if [[ "$f" == \.json$ ]]; then
                  cat -- "$f"
                else
                  ./scripts/common/properties_to_json.sh < "$f"
                fi \
                | jq -c -r 'if .domains != null then (.domains | split("\\s+"; "")) else "" end'
                # ^ ohne Domains: Leerstring => jq -r gibt nichts aus => if [ -z "$domains" ] bleibt true.
                # mit Domains: jq split Ergebnis ist Array (z.B. ["km","mc"]); jq igoniert -r.
              )
            fi
          done
          printf 'domains: %s\n' "$domains"

          # Ergebnis: domains JSON Array wie ["km","mc"] oder Default ["-"]
          printf '::set-output name=domain_matrix::%s\n' "${domains:-[\"-\"]}"

      # Prüft, ob deployed werden soll
      - name: Check for deployment
        id: deployment-check
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'

          enabled=$(
            for f in \
              "./properties/${component}/kubernetes-deployment.json" \
              "./properties/${component}/kubernetes-deployment-${environment}.json"
            do
              printf '%s existiert' "$f" >&2
              if [ -e "$f" ]; then echo >&2; cat -- "$f"; else echo ' nicht' >&2; fi
            done | jq -s -r 'add | .enabled'
          )

          printf '::set-output name=deployment_enabled::%s\n' "$enabled"

    outputs:
      deployment_enabled: ${{ steps.deployment-check.outputs.deployment_enabled }}
      domain_matrix: ${{ steps.set-matrix.outputs.domain_matrix }}

  helm-deployment:
    needs: build-matrix
    if: ${{ needs.build-matrix.outputs.deployment_enabled == 'true' }}
    runs-on: [self-hosted,vm]
    container:
      image: docker.mobilcom.de/dpvo/cicd-kubernetes-helm3:latest
    strategy:
      fail-fast: false
      matrix:
        domain: ${{ fromJson(needs.build-matrix.outputs.domain_matrix) }}
    env:
      JAVA_VERSION: 11

    steps:
      # Leeren Workspace sicherstellen
      - name: Ensure clean workspace
        run: |
          echo "Cleaning up previous run"
          chown -R "$(id -u):$(id -g)" . || true
          rm -rf *

      - name: Clean
        uses: AutoModality/action-clean@v1.1.0

      # jq installieren
      - name: Setup jq
        uses: freenet-actions/setup-jq@v1

      # Secrets aus AWS auslesen
      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: 'eu-central-1'
      - name: Read AWS Parameters
        uses: dkershner6/aws-ssm-getparameters-action@v1
        with:
          parameterPairs: |
            /github/secrets/mcbs_token = GITHUB_TOKEN

      # Auschecken des Deployment Repositories
      - name: Checkout Deployment Data / Scripts
        uses: actions/checkout@v3
        with:
          repository: freenet-group/ms-deployment
          token: ${{ env.GITHUB_TOKEN }}
          ref: ${{ github.event.inputs.deploymentRepositoryBranch }}

      # kubernetes-deployment JSON einlesen
      - name: Read kubernetes-deployment.json
        shell: bash
        run: |
          component='${{ github.event.inputs.component }}'
          environment='${{ github.event.inputs.environment }}'

          # Das letzte JSON-Objekt (Datei mit -${environment}) gewinnt in jq add.
          {
            printf '{ "secrets": [] }\n'  # Default hier beimischen ist einfacher als immer ohne "secrets" auszukommen.
            for f in "./properties/${component}/kubernetes-deployment.json" "./properties/${component}/kubernetes-deployment-${environment}.json"; do
              printf '%s existiert' "$f" >&2
              if [ -e "$f" ]; then echo >&2; cat -- "$f"; else echo ' nicht' >&2; fi
            done \
          } | jq -s add | tee kubernetes-deployment.generated.json

      # kubernetes-deployment JSON auswerten
      - name: Process kubernetes-deployment.generated.json
        shell: bash
        run: |
          # Umgebungsvariablen setzen
          jq -r '
              "K8S_CLUSTER="        + (.cluster       // ("cluster fehlt"       | halt_error)) + "\n" +
              "K8S_ENVIRONMENT="    + (.environment   // ("environment fehlt"   | halt_error)) + "\n" +
              "K8S_NAMESPACE="      + (.namespace     // ("namespace fehlt"     | halt_error)) + "\n" +
              "K8S_COMPONENT_NAME=" + (.componentName // ("componentName fehlt" | halt_error)) + "\n" +
              ""' \
            < kubernetes-deployment.generated.json \
          | tee -a -- "$GITHUB_ENV"

          # parameterPairs für aws-ssm-getparameters-action ermitteln aus .secrets in kubernetes-deployment.generated.json
          # Beispiel:
          # kubernetes-deployment.generated.json enthält:
          # {
          # 	...
          # 	"secrets": [
          # 		{
          # 			"sourceType": "AWS_PARAMETER",
          # 			"source": "/config/ms/homer/homer.prince.license",
          # 			"targetType": "FILE",
          # 			"target": "/usr/lib/prince/license/license.dat"
          # 		},
          # 		{
          # 			"sourceType": "AWS_PARAMETER",
          # 			"source": "/config/ms/application/test",
          # 			"targetType": "ENV",
          # 			"target": "TEST_VAR",
          # 			"conversion": "b64enc"
          # 		},
          # 		{
          # 			"sourceType": "SOMETHING_UNSUPPORTED",
          # 			"source": "...",
          # 			"targetType": "...",
          # 			"target": "..."
          # 		}
          # 	]
          # }
          # => jq Ergebnis:
          #   /config/ms/homer/homer.prince.license=AWS_DYNAMIC_PARAM_NAME1,
          #   /config/ms/application/test=AWS_DYNAMIC_PARAM_NAME2,
          paramPairs=$(jq -r '
              [ .secrets[] | select(.sourceType == "AWS_PARAMETER") ]
              | foreach .[] as $x (0; . + 1; "\($x.source)=AWS_DYNAMIC_PARAM_NAME\(.),")' \
            < kubernetes-deployment.generated.json)

          # Als (mehrzeilige) Umgebungsvariable DYNAMIC_AWS_PARAM_PAIRS setzen:
          printf 'DYNAMIC_AWS_PARAM_PAIRS<<...snip...\n%s\n...snip...\n' "$paramPairs" \
          | tee -a -- "$GITHUB_ENV"

      # Secrets für K8S Deployment aus AWS auslesen
      - name: Read AWS Parameters for K8S Deployment
        uses: dkershner6/aws-ssm-getparameters-action@v1
        with:
          parameterPairs: |
            ${{ env.DYNAMIC_AWS_PARAM_PAIRS }}
            /kubernetes/${{ env.K8S_ENVIRONMENT }}/namespace/${{ env.K8S_NAMESPACE }}/k8s-token = K8S_TOKEN,
            /kubernetes/github-packages/token = K8S_REGISTRY,
            /github/secrets/jasypt_encryptor_password = JASYPT_ENCRYPTOR_PASSWORD

      # AWS Secrets aus Umgebungsvariablen in JSON für Helm umwandeln
      - name: AWS Parameters to Helm JSON
        shell: bash
        run: |
          # Beispiel (Fortsetzung): aws-ssm-getparameters-action hat dann Umgebungsvariablen gesetzt:
          # - DYNAMIC_AWS_PARAM_PAIRS1 mit dem Wert X für "/config/ms/homer/homer.prince.license",
          # - DYNAMIC_AWS_PARAM_PAIRS2 mit dem Wert Y für "/config/ms/application/test".
          # Daraus machen wir jetzt kubernetes-secrets.generated.json in dem im Helm Chart erwarteten Format:
          # {
          # 	"secrets": [
          # 		{
          # 			"type": "FILE"
          # 			"key": "/usr/lib/prince/license/license.dat",
          # 			"value": "X"
          # 		},
          # 		{
          # 			"type": "ENV",
          # 			"key": "TEST_VAR",
          # 			"value": "Y",
          # 			"conversion": "b64enc"
          # 		}
          # 	]
          # }
          jq '
              [
                [.secrets[] | select(.sourceType == "AWS_PARAMETER")]
                | foreach .[] as $x (
                    0;
                    . + 1;
                    {
                      "type": $x.targetType,
                      "key": $x.target,
                      "value": env["AWS_DYNAMIC_PARAM_NAME\(.)"],
                      "MISSING_AWS_DYNAMIC_PARAM_NAME": (if env["AWS_DYNAMIC_PARAM_NAME\(.)"] == null then $x.source else null end),
                      "conversion": $x.conversion
                    }
                  )
                | with_entries(select(.value != null))
              ]
              | { "secrets": . }' \
          < kubernetes-deployment.generated.json \
          > kubernetes-secrets-all.generated.json
          # ^ Das ".value" in with_entries(select(.value != null)) ist nicht der "value" Key, sondern bei with_entries
          # der jeweilige JSON Value! Damit unterdrücken wir neben "value": null Einträgen z.B. auch "conversion": null.

          # Der Fall "value" == null (d.h. env["AWS_DYNAMIC_PARAM_NAME<n>"] null, d.h. Param-Name $x.source nicht im AWS
          # gefunden, kommt jetzt: Warnen und in Endergebnis kubernetes-secrets.generated.json weglassen:
          missingParams=$(jq -r '[.secrets[].MISSING_AWS_DYNAMIC_PARAM_NAME | select(. != null)] | join(", ")' < kubernetes-secrets-all.generated.json)
          if [ -n "$missingParams" ]; then printf '::warning::Nicht im AWS ParameterStore gefunden: %s\n' "$missingParams" >&2; fi
          jq '[.secrets[] | select(.value != null)] | { "secrets": . }' \
          < kubernetes-secrets-all.generated.json \
          | tee kubernetes-secrets.generated.json

      # Kubernetes Login
      - name: Login
        run: /root/init-kubectl-auth.sh 'https://${{ env.K8S_CLUSTER }}' '${{ env.K8S_TOKEN }}'

      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: zulu
          java-version: ${{ env.JAVA_VERSION }}

      # deployment.json aus deployment*.properties generieren
      - name: Deployment Properties to JSON
        shell: bash
        run: |
          ./scripts/microservice/ms_properties_to_json.sh '${{ github.event.inputs.component }}' '${{ github.event.inputs.environment }}' \
          | tee deployment.generated.json

      - name: Helm Deployment
        shell: bash
        run: |
          domain='${{ matrix.domain }}'
          component='${{ github.event.inputs.component }}'
          componentVersion='${{ github.event.inputs.componentVersion }}'
          environment='${{ github.event.inputs.environment }}'
          timeout='${{ github.event.inputs.timeout }}'
          dryRun=${{ github.event.inputs.dryRun }}

          helmOpts=()
          if $dryRun; then helmOpts=(--dry-run); fi

          # von Domain abhängige Helm Optionen
          if [ "$domain" = '-' ]; then
            name=$K8S_COMPONENT_NAME
            helmOpts=( "${helmOpts[@]}" "--set=hostname=${component}-${environment}" )
          else
            name=${K8S_COMPONENT_NAME}-${domain}
            helmOpts=(
              "${helmOpts[@]}"
              "--set=domain=$domain"
              "--set=hostname=${component}-${domain}-${environment}"
            )
          fi

          chartDir="helm/$component"
          if [ ! -d "$chartDir" ]; then chartDir=helm/ms; fi

          # --values Helm Optionen
          # Die letzte Datei gewinnt in helm --values.
          for f in \
              deployment.generated.json \
              "$chartDir/stages/${environment}.yaml" \
              kubernetes-deployment.generated.json \
              kubernetes-secrets.generated.json
          do
            if [ -e "$f" ]; then
              helmOpts=("${helmOpts[@]}" "--values=$f")
            fi
          done

          # vor dem Deplyoment helm status --namespace="$K8S_NAMESPACE" "$K8S_COMPONENT_NAME" 
          # in einer Schleife (10s warten, insgesamt max. maxWaitForDeployment) prüfen
          maxWait='${{ github.event.inputs.maxWaitForDeployment }}'
          maxWait=${maxWait//h/hour}; maxWait=${maxWait//m/min}; maxWait=${maxWait//s/sec}
          maxWaitTimestamp=$(date -d "now +$maxWait" +%s)
          helmExit=0
          
          if  helm list --namespace="$K8S_NAMESPACE" | cut -d ' ' -f 1 | grep -Fxq -- "$K8S_COMPONENT_NAME"; then
              while [ "$(date +%s)" -lt "$maxWaitTimestamp" ]; do
                  helmStatus=$(helm status --output=json --namespace="$K8S_NAMESPACE" "$K8S_COMPONENT_NAME" | jq -r .info.status)
                  if  [[ "${helmStatus#pending}" != "$helmStatus" ]]; then
                      echo "Helm Status von $K8S_COMPONENT_NAME: $helmStatus, warte $waitPeriod s ..."
                      sleep 10
                      helmExit=1
                  else
                      echo "Helm Status von $K8S_COMPONENT_NAME: $helmStatus, starte Deplyoment ..."
                      maxWaitTimestamp=$(date -d "now" +%s)
                      helmExit=0
                  fi
              done
              if [ $helmExit -eq 1 ]; then
                  echo "Wartezeit überschritten, breche ab..."
                  exit 1
              fi
          fi

          # helm Befehl ausgeben, damit man ihn bei Fehler leicht nochmal manuell wiederholen kann
          # (ohne weiter Github Actions Spam zu senden). Secrets im Log sollte Github ja automatisch
          # unkenntlich machen.
          set -x

          # --set="environment=$environment": Wert aus Workflow Parameter (z.B. "dev") hat Vorrang
          # vor dem environment (z.B. "np"), das wir für den AWS Parameternamen in
          # kubernetes-deployment*.json haben.
          helm upgrade --namespace="$K8S_NAMESPACE" \
            --install --atomic --timeout="$timeout" \
            "$name" "$chartDir" \
            "${helmOpts[@]}" \
            --set="environment=$environment" \
            --set="appName=$K8S_COMPONENT_NAME" \
            --set="docker_config_base64=$K8S_REGISTRY" \
            --set='aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}' \
            --set='aws_secret_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}' \
            --set="jasypt_password=$JASYPT_ENCRYPTOR_PASSWORD" \
            --set="version=$componentVersion"

      - name: Cleanup
        if: ${{ always() }}
        run: |
          set +e
          rm -rf /__w/_tool/*
