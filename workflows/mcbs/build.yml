name: Build

on:
  push:
    branches-ignore:
      - release**
  pull_request:
    branches-ignore:
      - release**
      - develop
  workflow_dispatch:
    inputs:
      gradleOptions:
        description: Zusätzliche optionale Gradle Parameter
        required: false
      product:
        description: Das zu bauende Produkt
        type: choice
        required: true
        default: ALL
        options:
          - ALL
          - ms-cuba
          - ms-customer
          - ms-customerelastic
          - ms-customerproduct
          - ms-mcbsservices
          - mcbs
          - mcbsservices
      epic:
        description: Das EPIC (JIRA) als Releaseklammer (META-170 = "unbestimmt")
        required: false
        default: META-170
      actionsRepositoryBranch:
        description: Zu benutzender Branch des Repositories mcbscore-github-actions
        required: false
        default: main
      manualVersion:
        description: Eine manuell zu vergebende Versionskennung (xx.yy.zz / ohne prefix) (Überschreibt ausschließlich die Version , keine Issues)
        required: false
      manualIssues:
        description: Eine blank-separierte Liste von Issues für das Patch-Release (Überschreibt ausschließlich die Issues , keine Version)
        required: false  

jobs:
  build:
    # self-hosted Runner für die Steps benutzen, um Zugriff auf MD Systeme zu haben
    runs-on: [self-hosted, vm]
    env:
      ACTIONS_REPOSITORY: freenet-group/mcbscore-github-actions
      ACTIONS_PATH: mcbscore/github
    strategy:
      matrix:
        product:
          - { id: mcbs, name: mcbs, group: standard }
          - { id: mcbsservices, name: zap, group: standard }
          - { id: ms-cuba, name: cuba, group: ms }
          - { id: ms-customer, name: customer, group: ms }
          - { id: ms-customerelastic, name: customerelastic, group: ms }
          - { id: ms-customerproduct, name: customerproduct, group: ms }
          - { id: ms-mcbsservices, name: mcbsservices, group: ms }

    steps:
      # Owner für alle Dateien des $GITHUB_WORKSPACE auf den Runner User setzen
      - name: Change Owner to Runner User
        if: ${{ always() && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        run: |
          githubUser='${{ github.actor }}'
          githubToken='${{ secrets.GH_R_PACKAGES }}'
          docker login ghcr.io -u "$githubUser" -p "$githubToken"
          docker run --rm -v "$(pwd):/target" -w /target -t ghcr.io/freenet-group/container-base-images/ubuntu_2004_lts:latest sh -c "chown $(id -u):$(id -g) -R /target"

      # Leeren Workspace sicherstellen
      - name: Ensure clean workspace
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        run: |
          echo "Cleaning up previous run"
          rm -rf -- *

      - name: Checkout Repository
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Read AWS Secrets
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbs_user = USER, 
            /github/secrets/mcbstest_credentials = MCBSTEST_CREDENTIALS,
            /github/secrets/mcbstest_username = LIQUIBASE_USERNAME,
            /github/secrets/mcbstest_password = LIQUIBASE_PASSWORD,
            /github/common/jira/api_url = JIRA_API_URL

      # Die internen Actions auschecken
      - name: checkout mcbscore-github-actions
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: actions/checkout@v3
        with:
          repository: ${{ env.ACTIONS_REPOSITORY }}
          token: ${{ env.TOKEN }}
          path: ${{ env.ACTIONS_PATH }}
          ref: ${{ github.event.inputs.actionsRepositoryBranch }}

      # ##################################################################################
      # Initialize Workflow
      # ##################################################################################

      - name: Initialize Workflow
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: ./mcbscore/github/actions/init-workflow
        with:
          installJava: true
          installGithubCli: true
          installJq: true
          configurationPrefix: ${{ matrix.product.name }}_

      # ##################################################################################
      # Version ermitteln
      # ##################################################################################

      - id: determine-build-type-and-branch-name
        name: Determine Build Type And Branch Name
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: ./mcbscore/github/actions/build-type-and-branch-name

      - id: determine-component-version
        name: Determine Component Version
        if: ${{ (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: ./mcbscore/github/actions/determine-component-version
        with:
          component: ${{ env.JIRA_COMPONENT }}
          versionByComponentList: true

      # component_Version ggf. manuell übersteuern, sofern eine Eingabe vorliegt
      - name: manualVersion
        if: ${{ github.event.inputs.manualVersion != '' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        shell: bash
        run: |
          echo "COMPONENT_VERSION=${{github.event.inputs.manualVersion}}"
          echo "COMPONENT_VERSION=${{github.event.inputs.manualVersion}}" >> $GITHUB_ENV
                    
      # issueList ggf. manuell übersteuern, sofern eine Eingabe vorliegt
      - name: manualIssues
        if: ${{ github.event.inputs.manualIssues != '' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        shell: bash
        run: |
          echo "ISSUE_LIST=${{github.event.inputs.manualIssues}}"
          echo "ISSUE_LIST=${{github.event.inputs.manualIssues}}" >> $GITHUB_ENV 
          
      - name: Set release version in db changes
        if: ${{ env.BUILD_TYPE == 'RELEASE' && env.DB_CHANGES_DIRECTORY != '' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        shell: bash
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

          find ./${{ env.DB_CHANGES_BASE_DIRECTORY }}/${{ env.DB_CHANGES_DIRECTORY }} -type f -exec sed -i 's/{releaseVersion}/${{ env.COMPONENT_VERSION }}/g' {} +
          
          git status --porcelain
          changesDetected=`git status --porcelain`

          if [ -n "$changesDetected" ]
          then
            echo "Committing changes"
            git commit -am "ReleaseVersion in DB Changes eingetragen"
            git push
          fi
        
          git tag -f -a sql-${{ env.TAG_PREFIX }}${{ env.COMPONENT_VERSION }} -m "tagging sql-${{ env.TAG_PREFIX }}${{ env.COMPONENT_VERSION }}"
          git push --tags -f

      - name: Scripte prüfen
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.id == 'mcbs' }}
        run: sh ./gradlew -PLI_username=${{ env.LIQUIBASE_USERNAME }} -PLI_password=${{ env.LIQUIBASE_PASSWORD }} -PLI_contexts=PROD -PARTIFACT_VERSION=${{ env.COMPONENT_VERSION }} -PGITHUB_USER=${{ env.USER }} -PGITHUB_TOKEN=${{ env.TOKEN }} -PINCLUDED_MODULES=${{ env.GRADLE_MODULES }} createReleaseScripts ${{ github.event.inputs.gradleOptions }}

      - id: gradle-build
        name: Gradle Build
        if: ${{ github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL' }}
        uses: ./mcbscore/github/actions/gradle-build
        with:
          artifactoryUserName: ${{ secrets.MD_ARTIFACTORY_USER }}
          artifactoryPassword: ${{ secrets.MD_ARTIFACTORY_PW }}
          sonarqubeToken: ${{ secrets.SONARQUBE_TOKEN }}
          sonarqubeUrl: ${{ secrets.SONARQUBE_HOST_URL }}
          gradleCommand: ${{ env.GRADLE_COMMAND }}
          gradlePublishCommand: ${{ env.GRADLE_PUBLISH_COMMAND }}
          gradleOptions: ${{ github.event.inputs.gradleOptions }}
          gradleProperties: '-PINCLUDED_MODULES=${{ env.INCLUDED_MODULES }}'

      # JUnit Ergebnisse publizieren
      - name: Upload Unit Test Results
        if: ${{ always() && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: actions/upload-artifact@v3
        with:
          name: Unit Test Results (${{ matrix.product.name }})
          path: '**/test-results/**/*.xml'

      # Existierende Draft Releases löschen
      - name: Delete draft releases
        if: ${{ env.BUILD_TYPE == 'DEVELOP' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        shell: bash
        run: |
          gh release list | sed 's/|/ /' | awk '{print $0, $8}' | while read -r line; do
            draftRelease=$(echo "$line" | grep -E '${{ env.TAG_PATTERN }}' | grep "Draft" | awk '{print $3}')
          
            if [ ! -z "$draftRelease" ]
            then
              echo "Deleting $draftRelease"
              gh release delete -y "$draftRelease"
            fi
          done
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}

      # Release erstellen
      - name: Create Release
        id: create_release
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          tag_name: ${{ env.TAG_PREFIX }}${{ env.COMPONENT_VERSION }}
          release_name: ${{ env.RELEASE_PREFIX }}${{ env.COMPONENT_VERSION }}
          draft: ${{ env.DRAFT }}
          prerelease: false

      # Release JAR hinzufügen
      - name: Upload Release JAR
        id: upload-release-jar
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL')  && matrix.product.group == 'ms' && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # Release ZIP hinzufügen
      - name: Upload Release ZIP
        id: upload-release-zip
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL')  && matrix.product.group == 'standard' && env.APPLICATION_ZIP_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_ZIP_PATH }}${{ env.APPLICATION_ZIP_NAME }}-${{ env.COMPONENT_VERSION }}.zip
          asset_name: ${{ env.APPLICATION_ZIP_NAME }}-${{ env.COMPONENT_VERSION }}.zip
          asset_content_type: application/zip

      # Vorhandene Open API Yamls als Asset hinzufügen
      - name: Upload API Doc Assets
        id: uploadApiDocs
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && env.API_DOC_YAML_PATTERN != '' }}
        uses: ./mcbscore/github/actions/upload-api-doc-assets
        with:
          version: ${{ env.TAG_PREFIX }}${{ env.COMPONENT_VERSION }}
          apiDocYmlPattern: ${{ env.API_DOC_YAML_PATTERN }}
          token: ${{ env.TOKEN }}

      # Docker Image erzeugen
      - name: Docker Image erzeugen
        id: createDockerImage
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.group == 'ms' }}
        uses: ./mcbscore/github/actions/microservice-docker-image-action
        with:
          componentName: ms-${{ env.COMPONENT }}
          componentVersion: ${{ env.COMPONENT_VERSION }}
          jar: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          javaVersion: ${{ env.JAVA_VERSION }}

      # Starte Deployment auf DEV
      - name: Invoke deployment workflow
        if: ${{ env.BUILD_TYPE == 'DEVELOP' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.group == 'ms' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: Deployment
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ matrix.product.name }}",
              "componentVersion": "${{ env.COMPONENT_VERSION }}",
              "environment": "dev",
              "tagPrefix": "${{ env.TAG_PREFIX }}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            }

      # Starte Deployment auf REF_CALLS
      - name: Invoke deployment workflow (ref_calls)
        if: ${{ env.BUILD_TYPE == 'RELEASE' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && github.event.inputs.product == 'mcbs' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: RefCalls Deployment
          token: ${{ env.TOKEN }}
          inputs: > 
            {
              "componentVersion": "${{ env.COMPONENT_VERSION }}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            }

      # Starte DB changes Workflow
      - name: Invoke db changes workflow
        if: ${{ env.BUILD_TYPE == 'RELEASE' && env.DB_CHANGES_DIRECTORY != '' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: DB Changes
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ matrix.product.name }}",
              "componentVersion": "${{ env.COMPONENT_VERSION }}",
              "tagPrefix": "${{ env.TAG_PREFIX }}"
            }

      # Starte postBuild auf RELEASE (MS)
      - name: Invoke postBuild workflow ms
        if: ${{ env.BUILD_TYPE == 'RELEASE' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.group == 'ms' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: PostBuild MS
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ matrix.product.name }}",
              "releaseVersion": "${{ env.COMPONENT_VERSION }}",
              "issueList": "${{ env.issueList }}",
              "epic": "${{ github.event.inputs.epic}}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            } 
      
      # Starte postBuild auf RELEASE (MCBS)
      - name: Invoke postBuild workflow mcbs
        if: ${{ env.BUILD_TYPE == 'RELEASE' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.id == 'mcbs' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: PostBuild MCBS
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ github.event.inputs.name}}",
              "releaseVersion": "${{ env.COMPONENT_VERSION }}",
              "issueList": "${{ env.issueList }}",
              "epic": "${{ github.event.inputs.epic}}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            }
      
      # Starte postBuild auf RELEASE (ZAP)
      - name: Invoke postBuild workflow mcbs
        if: ${{ env.BUILD_TYPE == 'RELEASE' && (github.event.inputs.product == matrix.product.id || github.event.inputs.product == 'ALL') && matrix.product.id == 'mcbsservices' }}
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: PostBuild ZAP
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ github.event.inputs.name}}",
              "releaseVersion": "${{ env.COMPONENT_VERSION }}",
              "issueList": "${{ env.issueList }}",
              "epic": "${{ github.event.inputs.epic}}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            }

  publish-test-results:
    name: Publish Unit Tests Results
    needs: build
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          path: artifacts

      - name: Publish Unit Test Results
        uses: EnricoMi/publish-unit-test-result-action@v1
        with:
          files: artifacts/**/*.xml