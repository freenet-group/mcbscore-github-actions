name: Release Service

on:
  pull_request:
    types: [closed]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Von welchem Branch soll ein Release gebaut werden z.B. "feature/ABRMS-*" "oder bugfix/MCBS-*"?'
        required: false
      ticket:
        description: 'Welches Ticket (MCBS-1234 / ABRMS-1234) soll für das Release verwendet werden?'
        required: true
      version:
        description: 'Welche Version für das neue Release z.B. "8.32.1"?'
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  release:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    permissions:
      contents: write
      actions: write
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # Setup
      - uses: actions/checkout@v4

      - name: AWS Credentials konfigurieren
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: 'eu-central-1'

      - name: Config von AWS SSM einlesen
        uses: dkershner6/aws-ssm-getparameters-action@v2
        with:
          parameterPairs: |
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbstest_jiracloud_credentials = MCBSTEST_JIRACLOUD_CREDENTIALS,
            /github/common/jira/jira_cloud_url = JIRA_CLOUD_URL

      - name: workflow.config einlesen
        id: read-properties
        run: |
          tee -a "$GITHUB_OUTPUT" < .github/workflow.config

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ steps.read-properties.outputs.NODE_VERSION }}
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com/'

      - name: Dependencies installieren
        run: npm ci
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GH_R_PACKAGES }}

      - name: SBOM Generieren
        if: ${{ steps.read-properties.outputs.SBOM_FILE != '' }}
        run: |
          mkdir -p ./src/.generated
          npm run generate:sbom

      # Versionierung
      - name: Release Label einlesen
        id: release-label
        uses: actions-ecosystem/action-release-label@v1
        with:
          label_prefix: 'release:'

      - name: Letztes Release Tag holen
        id: get-latest-tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        with:
          initial_version: 0.0.0
          semver_only: true

      - name: Semantic Version hochzählen
        id: bump-semver
        uses: actions-ecosystem/action-bump-semver@v1
        with:
          current_version: ${{ steps.get-latest-tag.outputs.tag  }}
          level: ${{ steps.release-label.outputs.level || 'patch' }}

      - name: Semantic Version überschreiben, wenn eine spezifische Version angegeben wurde
        id: version-calculation
        run: |
          # Setze die neue kalkulierte Version in die Outputs
          echo "new_version=${{ steps.bump-semver.outputs.new_version }}" >> $GITHUB_OUTPUT

          # Überschreibe die neue kalkulierte Version, wenn eine spezifische Version angegeben wurde
          if [ -n "${{ github.event.inputs.version }}" ]; then
            echo "new_version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Neuen Versions-Tag einchecken
        uses: actions-ecosystem/action-push-tag@v1
        with:
          tag: ${{ steps.version-calculation.outputs.new_version }}
          message: '${{ steps.version-calculation.outputs.new_version }}: PR #${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}'

      # Release Template
      - name: Issue-List Alternative aus Diff zur neuen Version erzeugen
        id: jira_keys
        uses: varnerknut/jira-extract-issue-keys-from-tags@1.3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          head-tag: ${{ steps.version-calculation.outputs.new_version }}

      - name: Release-Template einlesen und ausfüllen
        id: update_release_template
        run: |
          template_file=".github/templates/release_template_npmlib.md"
          issueList=""
          issueListLines=""
          linkIssuesListLines=""
          allComponentList=""
          dependencyList=""
          linkedIssuesListLines=""
          epicList=""

          # Setting default outputs
          echo "issue_list=" >> "$GITHUB_OUTPUT"
          echo "renovate=false" >> "$GITHUB_OUTPUT"
          echo "renovate_title=" >> "$GITHUB_OUTPUT"
          echo "epic_list=" >> "$GITHUB_OUTPUT"
          echo "epic_due_date=" >> "$GITHUB_OUTPUT"
          echo "dependencies=false" >> "$GITHUB_OUTPUT"

          # Alle Issues auslesen
          if [ -n "${{ steps.jira_keys.outputs.issue-keys }}" ]; then
            issueList=$(echo "${{ steps.jira_keys.outputs.issue-keys }}")
          fi

          # Prüfen ob der Input "ticket" gesetzt wurde, wenn ja, dann hinzufügen
          if [ -n "${{ github.event.inputs.ticket }}" ]; then
            if [ -z "$issueList" ]; then
              issueList="${{ github.event.inputs.ticket }}"
            else
              issueList+=",${{ github.event.inputs.ticket }}"
            fi
          fi

          # Prüfen ob das label "renovate" im PR gesetzt wurde
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            prNumber=$(jq -r ".pull_request.number" "$GITHUB_EVENT_PATH")
            apiResponse=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${prNumber}/labels")

            # Prüfen ob es sich um ein Array oder einen String handelt
            if echo "$apiResponse" | jq -e 'type == "array"' > /dev/null; then
              prLabels=$(echo "$apiResponse" | jq -r ".[].name")
            else
              prLabels=$(echo "$apiResponse" | jq -r ".name")
            fi

            # ABRMS-5265 ist ein Renovate-Platzhalterticket, wenn renovate im PR-Label enthalten ist, dann hinzufügen
            if echo "$prLabels" | grep -q "renovate"; then
              if [ -z "$issueList" ]; then
                issueList="ABRMS-5265"
              else
                issueList+=",ABRMS-5265"
              fi
            fi
          fi

          # Issue-Liste bereinigen
          uniqueIssueList=$(echo "$issueList" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')

          # IssueList / Implemented Issues
          echo "issue_list=$uniqueIssueList" >> "$GITHUB_OUTPUT"
          echo "Folgende Issues werden analysiert $uniqueIssueList"
          IFS=',' read -ra issues <<< "$uniqueIssueList"
          for line in "${issues[@]}"; do
            # Tabellen Eintrag erstellen
            issueNumber=$(echo "$line" | cut -d";" -f1 | xargs)
            echo "$issueNumber wird eingelesen"

            # Renovate Ticket überspringen, Rest aber prüfen
            if [ "$issueNumber" = "ABRMS-5265" ]; then
              title="${{ github.event.pull_request.title }}"
              issueListLines+="| ABRMS-5265 | $title | Renovate | Renovate |\n"
              echo "renovate=true" >> "$GITHUB_OUTPUT"
              echo "renovate_title=$title" >> "$GITHUB_OUTPUT"
              continue  # Rest überspringen
            fi

            # Jira Ticket einlesen
            echo "Jira CLI wird zu $issueNumber befragt"
            API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$issueNumber"
            BASIC_AUTH=$(echo -n ${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }} | base64 -w0)
            AUTH_HEADER="Authorization: Basic $BASIC_AUTH"
            issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")

            # Epic / Parent ermitteln
            echo "Epic name for $issueNumber is being extracted"
            epicKey=$(echo "$issue_info" | jq -r '.fields.parent.key')
            echo "Extracted epicKey: $epicKey"
            if [ -n "$epicKey" ] && [ "$epicKey" != "null" ]; then
              if [ -z "$epicList" ]; then
                epicList="$epicKey"
              else
                epicList="$epicList,$epicKey"
              fi
            fi

            # Titel einlesen
            echo "Titel zu $issueNumber extrahieren"
            title=$(echo "$issue_info" | jq -r '.fields.summary')

            # Jira-Labels einlesen
            echo "Jira-Labels zu $issueNumber extrahieren"
            jiraLabels=$(echo "$issue_info" | jq -r '.fields.labels[]' | paste -sd ", ")

            # Komponenten extrahieren
            echo "Komponenten zu $issueNumber extrahieren"
            componentList=$(echo "$issue_info" | jq -r '.fields.components[].name' | paste -sd ", ")
            allComponentList+=$componentList

            # Dependencies extrahieren
            echo "Dependencies zu $issueNumber extrahieren"
            custom_field_value=$(echo "$issue_info" | jq -r '.fields.customfield_10686')
            if [ ! -z "$custom_field_value" ] && [ "$custom_field_value" != "null" ]; then
              dependencyList+="\t * :warning: $issueNumber: $custom_field_value\n"
            else
              echo "No dependencies found for issue $issueNumber"
            fi

            # Ticket Tabelle ausfüllen
            echo "Tabelleneintrag zum Ticket $issueNumber wird erstellt"
            issueListLines+="| $issueNumber | $title | $jiraLabels | $componentList |\n"

            # Verknüpfte Tickets
            echo "Verknüpfte Tickets zu $issueNumber einlesen und Tabelle befüllen"
            for k in $(jq '.fields.issuelinks | keys | .[]' <<<"$issue_info"); do
              linkedIssue=$(jq -r ".fields.issuelinks[$k]" <<<"$issue_info");

              # Prüfe auf ausgehende/eingehende Links
              isOutward=$(jq 'has("outwardIssue")' <<<"$linkedIssue")
              if $isOutward; then
                linkedRelation=$(jq -r '.type.outward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.outwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.outwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.outwardIssue.fields.status.name' <<<"$linkedIssue")
              else
                linkedRelation=$(jq -r '.type.inward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.inwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.inwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.inwardIssue.fields.status.name' <<<"$linkedIssue")
              fi
                linkedIssuesListLines+="| $linkedIssueNumber | $linkedSummary | $linkedStatus | $linkedRelation |\n"
                echo "Verknüpftes Ticket erkannt: $linkedIssueNumber - $linkedSummary"
            done
          done

          # Platzhalter austauschen
          echo "Platzhalter im Template austauschen"

          ## Tabellen
          # Leerzeile und Platzhalter ersetzten
          echo "IssueList setzen"
          escapedIssueListLines=$(echo "$issueListLines" | sed 's/[&/\]/\\&/g')
          echo "$issueListLines"
          sed -i "/^$/N;/\n<!-- IMPLEMENTED_ISSUES_PLACEHOLDER -->/s~.*~$escapedIssueListLines~" "$template_file"

          # Verlinkte Tickets setzen
          echo "Verlinkte Tickets setzen"
          escapedLinkedIssuesListLines=$(echo "$linkedIssuesListLines" | sed 's/[&/\]/\\&/g')
          echo "$linkedIssuesListLines"
          sed -i "/^$/N;/\n<!-- IMPLEMENTED_LINKED_ISSUES_PLACEHOLDER -->/s~.*~$escapedLinkedIssuesListLines~" "$template_file"

          ## EPIC
          echo "EPIC setzen"
          echo "Final epicList: $epicList"
          if [ -n "$epicList" ]; then
            echo "epic_list=$epicList" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/$epicList/" "$template_file";
          else
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/:white_check_mark: Keine Änderung/" "$template_file";
          fi

          ## Dependencies
          echo "Dependencies setzen"
          if [ -n "$dependencyList" ]; then
            echo "dependencies=true" >> "$GITHUB_OUTPUT"
            dependencyList="\n$dependencyList"
            sed -i "s/<!-- DEPENDENCIES_PLACEHOLDER -->/$dependencyList/" "$template_file";
          else
            sed -i 's/<!-- DEPENDENCIES_PLACEHOLDER -->/:white_check_mark: Keine Dependencies/' "$template_file";
          fi

      - name: Release erstellen
        uses: softprops/action-gh-release@v2.0.8
        with:
          body_path: '.github/templates/release_template.md'
          files: |
            ${{ steps.read-properties.outputs.SBOM_FILE }}
          generate_release_notes: true
          name: ${{ steps.version-calculation.outputs.new_version }}
          tag_name: ${{ steps.version-calculation.outputs.new_version }}
          token: ${{ env.TOKEN }} # secrets.GITHUB_TOKEN würde keine Folge-WF triggern

      # Jira Fix-Version setzen
      - name: Jira Tickets aktualisieren
        run: |
          TICKETS="${{ steps.update_release_template.outputs.unique_issue_list }}"
          FIX_VERSION="${{ steps.version-calculation.outputs.new_version }}"

          IFS=',' read -r -a ticket_array <<< "$TICKETS"

          for ticket in "${ticket_array[@]}"; do
            echo "Updating Fix Version for $ticket"
            jira edit "$ticket" -o fixVersions="$FIX_VERSION"
          done

      # Im Fehlerfall aufräumen
      - name: Tag/Release löschen, wenn der Build fehlgeschlagen ist oder abgebrochen wurde
        if: failure() || cancelled()
        run: |
          if [ -n "${{ steps.version-calculation.outputs.new_version }}" ]; then
            # Wenn bereits ein Release zur Version erstellt wurde, dann lösche dieses. Ansonsten wird nur der Tag gelöscht
            if gh release list --json tagName --jq '.[] | select(.tagName == "${{ steps.version-calculation.outputs.new_version }}")' | grep -q '${{ steps.version-calculation.outputs.new_version }}'; then
              gh release delete ${{ steps.version-calculation.outputs.new_version }} --cleanup-tag --yes
            else
              git tag -d "${{ steps.version-calculation.outputs.new_version }}"
              git push origin ":${{ steps.version-calculation.outputs.new_version }}"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
