name: Release Service

on:
  pull_request:
    types: [closed]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Von welchem Branch soll ein Release gebaut werden z.B. "feature/ABRMS-*" "oder bugfix/MCBS-*"?'
        required: false
      ticket:
        description: 'Welches Ticket (MCBS-1234 / ABRMS-1234) soll für das Release verwendet werden?'
        required: true
      version:
        description: 'Welche Version für das neue Release z.B. "8.32.1"?'
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  release:
    if: ${{ github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: write
      actions: write
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # Setup
      - uses: actions/checkout@v4

      - name: AWS Credentials konfigurieren
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: 'eu-central-1'

      - name: Config von AWS SSM einlesen
        uses: dkershner6/aws-ssm-getparameters-action@v2
        with:
          parameterPairs: |
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbstest_jiracloud_credentials = MCBSTEST_JIRACLOUD_CREDENTIALS,
            /github/common/jira/jira_cloud_url = JIRA_CLOUD_URL

      - name: workflow.config einlesen
        id: read-properties
        run: |
          while IFS='=' read -r key value
          do
            # Leerzeilen und Kommentare überspringen
            if [[ -z "$key" || "$key" =~ ^// ]]; then
              continue
            fi
            echo "$key=$value" >> $GITHUB_OUTPUT
          done < .github/workflow.config

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ steps.read-properties.outputs.NODE_VERSION }}
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com/'

      - name: Dependencies installieren
        run: npm ci
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GH_R_PACKAGES }}

      - name: SBOM Generieren
        if: ${{ steps.read-properties.outputs.SBOM_FILE != '' }}
        run: |
          mkdir -p ./src/.generated
          npm run generate:sbom

      # Versionierung
      - name: Release Label einlesen
        id: release-label
        uses: actions-ecosystem/action-release-label@v1
        with:
          label_prefix: 'release:'

      - name: Letztes Release Tag holen
        id: get-latest-tag
        uses: actions-ecosystem/action-get-latest-tag@v1
        with:
          initial_version: 0.0.0
          semver_only: true

      - name: Semantic Version hochzählen
        id: bump-semver
        uses: actions-ecosystem/action-bump-semver@v1
        with:
          current_version: ${{ steps.get-latest-tag.outputs.tag  }}
          level: ${{ steps.release-label.outputs.level || 'patch' }}

      - name: Semantic Version überschreiben, wenn eine spezifische Version angegeben wurde
        id: version-calculation
        env: 
          NEW_VERSION: ${{ steps.bump-semver.outputs.new_version }}
          INPUT_VERSION: ${{ github.event.inputs.version }}
        run: |
          # Setze die neue kalkulierte Version in die Outputs
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT

          # Überschreibe die neue kalkulierte Version, wenn eine spezifische Version angegeben wurde
          if [ -n "${INPUT_VERSION}" ]; then
            echo "new_version=${INPUT_VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Neuen Versions-Tag einchecken
        uses: actions-ecosystem/action-push-tag@v1
        with:
          tag: ${{ steps.version-calculation.outputs.new_version }}
          message: '${{ steps.version-calculation.outputs.new_version }}: PR #${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}'

      # Release Template
      - name: Issue-List Alternative aus Diff zur neuen Version erzeugen
        id: jira_keys
        uses: varnerknut/jira-extract-issue-keys-from-tags@1.3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          head-tag: ${{ steps.version-calculation.outputs.new_version }}

      - name: Release-Template einlesen und ausfüllen
        id: update_release_template
        env:
          ISSUE_KEYS: ${{ steps.jira_keys.outputs.issue-keys }}
          INPUT_TICKET: ${{ github.event.inputs.ticket }}
        run: |
          template_file=".github/templates/release_template_npmlib.md"
          issueList=""
          issueListLines=""
          linkIssuesListLines=""
          dependencyList=""
          linkedIssuesListLines=""
          epicList=""

          # Setting default outputs
          echo "issue_list=" >> "$GITHUB_OUTPUT"
          echo "renovate=false" >> "$GITHUB_OUTPUT"
          echo "renovate_title=" >> "$GITHUB_OUTPUT"
          echo "epic_list=" >> "$GITHUB_OUTPUT"
          echo "epic_due_date=" >> "$GITHUB_OUTPUT"
          echo "dependencies=false" >> "$GITHUB_OUTPUT"

          # Alle Issues auslesen
          if [ -n "$ISSUE_KEYS" ]; then
            issueList="$ISSUE_KEYS"
          fi

          # Prüfen ob der Input "ticket" gesetzt wurde, wenn ja, dann hinzufügen
          if [ -n "$INPUT_TICKET" ]; then
            if [ -z "$issueList" ]; then
              issueList="$INPUT_TICKET"
            else
              issueList+=",$INPUT_TICKET"
            fi
          fi

          # Prüfen ob das label "renovate" im PR gesetzt wurde
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            prNumber=$(jq -r ".pull_request.number" "$GITHUB_EVENT_PATH")
            apiResponse=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${prNumber}/labels")

            # Prüfen ob es sich um ein Array oder einen String handelt
            if jq -e 'type == "array"' <<<"$apiResponse" > /dev/null; then
              prLabels=$(jq -r ".[].name" <<<"$apiResponse")
            else
              prLabels=$(jq -r ".name" <<<"$apiResponse")
            fi

            # ABRMS-5265 ist ein Renovate-Platzhalterticket, wenn renovate im PR-Label enthalten ist, dann hinzufügen
            if echo "$prLabels" | grep -q "renovate"; then
              if [ -z "$issueList" ]; then
                issueList="ABRMS-5265"
              else
                issueList+=",ABRMS-5265"
              fi
            fi
          fi

          # Issue-Liste bereinigen
          uniqueIssueList=$(echo "$issueList" | tr ',' '\n' | sort -u | tr '\n' ',' | sed 's/,$//')

          # IssueList / Implemented Issues
          echo "issue_list=$uniqueIssueList" >> "$GITHUB_OUTPUT"
          echo "Folgende Issues werden analysiert $uniqueIssueList"
          IFS=',' read -ra issues <<< "$uniqueIssueList"
          for issueNumber in "${issues[@]}"; do
            # Tabellen Eintrag erstellen
            echo "$issueNumber wird eingelesen"

            # Renovate Ticket überspringen, Rest aber prüfen
            if [ "$issueNumber" = "ABRMS-5265" ]; then
              title="${{ github.event.pull_request.title }}"
              issueListLines+="| ABRMS-5265 | $title | Renovate | Renovate |\n"
              echo "renovate=true" >> "$GITHUB_OUTPUT"
              echo "renovate_title=$title" >> "$GITHUB_OUTPUT"
              continue  # Rest überspringen
            fi

            # Jira Ticket einlesen
            echo "Jira API wird zu $issueNumber befragt"
            API_ENDPOINT="${{ env.JIRA_CLOUD_URL }}issue/$issueNumber"
            BASIC_AUTH=$(echo -n "${{ env.MCBSTEST_JIRACLOUD_CREDENTIALS }}" | base64 -w0)
            AUTH_HEADER="Authorization: Basic $BASIC_AUTH"
            issue_info=$(curl -L -H "${AUTH_HEADER}" -H "Accept: application/json" "${API_ENDPOINT}")

            # Epic / Parent ermitteln
            echo "Epic name for $issueNumber is being extracted"
            if epicKey=$(jq -r -e '.fields.parent.key' <<<"$issue_info"); then  
              if [ -z "$epicList" ]; then epicList="$epicKey"; else epicList="$epicList,$epicKey"; fi  
              echo "Extracted epicKey: $epicKey"  
            fi

            # Titel einlesen
            echo "Titel zu $issueNumber extrahieren"
            title=$(jq -r '.fields.summary' <<<"$issue_info")

            # Jira-Labels einlesen
            echo "Jira-Labels zu $issueNumber extrahieren"
            jiraLabels=$(jq -r '.fields.labels[]' <<<"$issue_info" | paste -sd ", ")

            # Komponenten extrahieren
            echo "Komponenten zu $issueNumber extrahieren"
            componentList=$(jq -r '.fields.components[].name' <<<"$issue_info" | paste -sd ", ")

            # Dependencies extrahieren
            echo "Dependencies zu $issueNumber extrahieren"
            if custom_field_value=$(jq -r -e '.fields.customfield_10686' <<<"$issue_info"); then
              dependencyList+="\t * :warning: $issueNumber: $custom_field_value\n"
            else
              echo "No dependencies found for issue $issueNumber"
            fi

            # Ticket Tabelle ausfüllen
            echo "Tabelleneintrag zum Ticket $issueNumber wird erstellt"
            issueListLines+="| $issueNumber | $title | $jiraLabels | $componentList |\n"

            # Verknüpfte Tickets
            echo "Verknüpfte Tickets zu $issueNumber einlesen und Tabelle befüllen"
            jq -c '.fields.issuelinks[]' <<<"$issue_info" | while read -r linkedIssue; do
              # Prüfe auf ausgehende/eingehende Links
              isOutward=$(jq 'has("outwardIssue")' <<<"$linkedIssue")
              if [ "$isOutward" = "true" ]; then
                linkedRelation=$(jq -r '.type.outward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.outwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.outwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.outwardIssue.fields.status.name' <<<"$linkedIssue")
              else
                linkedRelation=$(jq -r '.type.inward' <<<"$linkedIssue")
                linkedIssueNumber=$(jq -r '.inwardIssue.key' <<<"$linkedIssue")
                linkedSummary=$(jq -r '.inwardIssue.fields.summary' <<<"$linkedIssue")
                linkedStatus=$(jq -r '.inwardIssue.fields.status.name' <<<"$linkedIssue")
              fi

              linkedIssuesListLines+="| $linkedIssueNumber | $linkedSummary | $linkedStatus | $linkedRelation |\n"
              echo "Verknüpftes Ticket erkannt: $linkedIssueNumber - $linkedSummary"
            done
          done

          # Platzhalter austauschen
          echo "Platzhalter im Template austauschen"
          
          ## Tabellen
          # Spezielle Sonderzeichen austauschen
          cleanedIssueListLines=$(printf '%s' "$issueListLines" | sed 's/[&/\#]/\\&/g')
          cleanedLinkedIssuesListLines=$(printf '%s' "$linkedIssuesListLines" | sed 's/[&/\#]/\\&/g')

          echo "IssueList setzen"
          echo "$cleanedIssueListLines"
          sed -i "/^$/N;/\n<!-- IMPLEMENTED_ISSUES_PLACEHOLDER -->/s#.*#$cleanedIssueListLines#" "$template_file"

          echo "Verlinkte Tickets setzen"
          echo "$cleanedLinkedIssuesListLines"
          sed -i "/^$/N;/\n<!-- IMPLEMENTED_LINKED_ISSUES_PLACEHOLDER -->/s#.*#$cleanedLinkedIssuesListLines#" "$template_file"

          ## EPIC
          echo "EPIC setzen"
          echo "Final epicList: $epicList"
          if [ -n "$epicList" ]; then
            echo "epic_list=$epicList" >> "$GITHUB_OUTPUT"
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/$epicList/" "$template_file";
          else
            sed -i "s/<!-- EPIC_PLACEHOLDER -->/:white_check_mark: Keine Änderung/" "$template_file";
          fi

          ## Dependencies
          echo "Dependencies setzen"
          if [ -n "$dependencyList" ]; then
            echo "dependencies=true" >> "$GITHUB_OUTPUT"
            dependencyList="\n$dependencyList"
            sed -i "s/<!-- DEPENDENCIES_PLACEHOLDER -->/$dependencyList/" "$template_file";
          else
            sed -i 's/<!-- DEPENDENCIES_PLACEHOLDER -->/:white_check_mark: Keine Dependencies/' "$template_file";
          fi

      - name: Release erstellen
        uses: softprops/action-gh-release@v2.0.8
        with:
          body_path: '.github/templates/release_template_npmlib.md'
          files: |
            ${{ steps.read-properties.outputs.SBOM_FILE }}
          generate_release_notes: true
          name: ${{ steps.version-calculation.outputs.new_version }}
          tag_name: ${{ steps.version-calculation.outputs.new_version }}
          token: ${{ env.TOKEN }} # secrets.GITHUB_TOKEN würde keine Folge-WF triggern

      # Jira Fix-Version setzen
      - name: Jira Tickets aktualisieren
        env:
          TICKETS: ${{ steps.update_release_template.outputs.issue_list }}
          FIX_VERSION: ${{ steps.version-calculation.outputs.new_version }}
        run: |
          IFS=',' read -r -a ticket_array <<< "$TICKETS"

          for ticket in "${ticket_array[@]}"; do
            echo "Updating Fix Version for $ticket"
            jira edit "$ticket" -o fixVersions="$FIX_VERSION"
          done

      # Im Fehlerfall aufräumen
      - name: Tag/Release löschen, wenn der Build fehlgeschlagen ist oder abgebrochen wurde
        if: failure() || cancelled()
        env:
          NEW_VERSION: ${{ steps.version-calculation.outputs.new_version }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "$NEW_VERSION" ]; then
            # Wenn bereits ein Release zur Version erstellt wurde, dann lösche dieses. Ansonsten wird nur der Tag gelöscht
            if gh release list --json tagName --jq '.[] | select(.tagName == "$NEW_VERSION") | .tagName' | grep -q .; then
              gh release delete "$NEW_VERSION" --cleanup-tag --yes
            else
              git tag -d "$NEW_VERSION"
              git push origin ":$NEW_VERSION"
            fi
          fi
