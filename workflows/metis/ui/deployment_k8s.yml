name: K8s Deployment
#Name fuer den workflow. Wichtig bei mehreren workflows im selben Repository um die workflows im actions-tab unterscheiden zu koennen.
run-name: K8s ${{ github.event.inputs.environment }} Deployment ${{ github.event.inputs.componentVersion }} dry=${{ github.event.inputs.dryRun }}

on:
  workflow_dispatch:
    inputs:
      componentVersion:
        description: Die Version der Komponente
        required: true
      environment:
        description: Die Zielumgebung
        required: true
      timeout:
        description: Zeit, nach der das Helm Deployment zurückgerollt wird, wenn noch nicht erfolgreich
        required: false
        default: 3m30s
      deploymentRepositoryBranch:
        description: Branch von Repository ms-deployment, der benutzt werden soll
        required: false
        default: main
      dryRun:
        type: boolean
        description: Nicht deployen, nur Helm Chart Ergebnis anzeigen (helm --dry-run)
        required: false
        default: false

jobs:
  helm-deployment:
    runs-on: [self-hosted, k8s]
    env:
      COMPONENT: metis-ui
      DEPLOYMENT_PATH: mcbscore/deployment

    steps:
      # Leeren Workspace sicherstellen
      - name: Ensure clean workspace
        run: |
          echo "Cleaning up previous run"
          chown -R "$(id -u):$(id -g)" . || true
          rm -rf *

      - name: Clean
        uses: AutoModality/action-clean@v1.1.0

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Select Github Secrets for AWS
        uses: ./.github/actions/select-aws-github-secrets
        with:
          environment: ${{ inputs.environment }}
          awsAccessKeyId:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsAccessKeyIdProd: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          awsSecretAccessKey:     ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsSecretAccessKeyProd: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}

      - name: Read AWS Secrets
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ env.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ env.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = GITHUB_TOKEN

      # Auschecken des Deployment Repositories
      - name: Checkout Deployment Data / Scripts
        uses: actions/checkout@v3
        with:
          repository: freenet-group/ms-deployment
          token: ${{ env.GITHUB_TOKEN }}
          path: ${{ env.DEPLOYMENT_PATH }}
          ref: ${{ github.event.inputs.deploymentRepositoryBranch }}

      # jq installieren
      - name: Setup jq
        uses: freenet-actions/setup-jq@v2

      # kubernetes-deployment JSON einlesen
      - name: Read kubernetes-deployment.json
        shell: bash
        run: |
          environment='${{ github.event.inputs.environment }}'

          # Das letzte JSON-Objekt (Datei mit -${environment}) gewinnt in jq add.
          for f in "./${{ env.DEPLOYMENT_PATH }}/properties/${COMPONENT}/kubernetes-deployment.json" "./${{ env.DEPLOYMENT_PATH }}/properties/${COMPONENT}/kubernetes-deployment-${environment}.json"; do
            printf '%s existiert' "$f" >&2
            if [ -e "$f" ]; then echo >&2; cat -- "$f"; else echo ' nicht' >&2; fi
          done \
          | jq -s -r 'add | (
            "K8S_CLUSTER=" + .cluster + "\n" +
            "K8S_ENVIRONMENT=" + .environment + "\n" +
            "K8S_NAMESPACE=" + .namespace + "\n" +
            "K8S_COMPONENT_NAME=" + .componentName + "\n" +
            "HELM_CHART=" + (.helmChart // "ms") + "\n" +
            "K8S_JAR_NAME=" + .jarName)' \
          | tee -a -- "$GITHUB_ENV"

      # Secrets aus AWS auslesen 2
      - name: Read AWS Parameters 2
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ env.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ env.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /kubernetes/${{ env.K8S_ENVIRONMENT }}/namespace/${{ env.K8S_NAMESPACE }}/k8s-token = K8S_TOKEN,
            /kubernetes/github-packages/token = K8S_REGISTRY

      # Kubernetes Login
      - name: 'Login k8s/helm'
        uses: freenet-actions/prepare-k8s-env@v1
        with:
         k8s-host-url: 'https://${{ env.K8S_CLUSTER }}'
         k8s-token: ${{ env.K8S_TOKEN }}

      # Helm Deployment
      - name: Helm Deployment
        shell: bash
        run: |
          environment='${{ github.event.inputs.environment }}'
          componentVersion='${{ github.event.inputs.componentVersion }}'
          timeout='${{ github.event.inputs.timeout }}'
          dryRun=${{ github.event.inputs.dryRun }}
          helmOpts=()
          if $dryRun; then helmOpts=(--dry-run); fi

          chartDir="${{ env.DEPLOYMENT_PATH }}/helm/$HELM_CHART"

          # --values Helm Optionen
          # Die letzte Datei gewinnt in helm --values.
          for f in \
              "$chartDir/stages/${environment}.yaml" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${COMPONENT}/kubernetes-deployment.json" \
              "./${{ env.DEPLOYMENT_PATH }}/properties/${COMPONENT}/kubernetes-deployment-${environment}.json"
          do
            if [ -e "$f" ]; then
              helmOpts=("${helmOpts[@]}" "--values=$f")
            fi
          done

          # helm Befehl ausgeben, damit man ihn bei Fehler leicht nochmal manuell wiederholen kann.
          # Secrets im Log sollte Github ja automatisch unkenntlich machen.
          set -x

          # --set="environment=$environment": Wert aus Workflow Parameter (z.B. "dev") hat Vorrang
          # vor dem environment (z.B. "np"), das wir für den AWS Parameternamen in
          # kubernetes-deployment*.json haben.
          helm upgrade --namespace="$K8S_NAMESPACE" \
            --install --atomic --timeout="$timeout" \
            "$K8S_COMPONENT_NAME" "$chartDir" \
            "${helmOpts[@]}" \
            --set="environment=$environment" \
            --set="hostname=${K8S_COMPONENT_NAME}-${environment}" \
            --set="appName=$K8S_COMPONENT_NAME" \
            --set="docker_config_base64=$K8S_REGISTRY" \
            --set="version=$componentVersion"

      - name: Cleanup
        if: ${{ always() }}
        run: |
          set +e
          rm -rf /__w/_tool/*