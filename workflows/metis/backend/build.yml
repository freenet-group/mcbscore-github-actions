name: Build

on:
  push:
    branches-ignore:
      - release
  pull_request:
    branches-ignore:
      - release
      - develop
  workflow_dispatch:
    inputs:
      gradleOptions:
        description: Zusätzliche optionale Gradle Parameter
        required: false
      epic:
        description: EPIC als eventuelle Releaseklammer (META-170 = keine / unbestimmt)
        required: false
        default: META-170
      actionsRepositoryBranch:
        description: Zu benutzender Branch des Repositories mcbscore-github-actions
        required: false
        default: main

jobs:
  build:
    # self-hosted Runner für die Steps benutzen, um Zugriff auf MD Systeme zu haben
    runs-on: [self-hosted, vm]
    env:
      ACTIONS_REPOSITORY: freenet-group/mcbscore-github-actions
      ACTIONS_PATH: mcbscore/github

    steps:
      # Owner für alle Dateien des $GITHUB_WORKSPACE auf den Runner User setzen
      - name: Change Owner to Runner User
        if: ${{ always() }}
        run: |
          githubUser='${{ github.actor }}'
          githubToken='${{ secrets.GH_R_PACKAGES }}'
          docker login ghcr.io -u "$githubUser" -p "$githubToken"
          docker run --rm -v "$(pwd):/target" -w /target -t ghcr.io/freenet-group/container-base-images/ubuntu_2004_lts:latest sh -c "chown $(id -u):$(id -g) -R /target"

      # Leeren Workspace sicherstellen
      - name: Ensure clean workspace
        run: |
          echo "Cleaning up previous run"
          rm -rf -- *

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Read AWS Secrets
        uses: ./.github/actions/read-aws-secrets
        with:
          awsAccessKeyId: ${{ secrets.AWS_ACCESS_KEY_ID }}
          awsSecretAccessKey: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          awsParameterPairs: |
            /github/secrets/mcbs_token = TOKEN,
            /github/secrets/mcbs_user = USER,
            /github/secrets/mcbstest_credentials = MCBSTEST_CREDENTIALS,
            /github/secrets/mcbstest_username = LIQUIBASE_USERNAME,
            /github/secrets/mcbstest_password = LIQUIBASE_PASSWORD,
            /github/common/jira/api_url = JIRA_API_URL

      # Die internen Actions auschecken
      - name: checkout mcbscore-github-actions
        uses: actions/checkout@v3
        with:
          repository: ${{ env.ACTIONS_REPOSITORY }}
          token: ${{ env.TOKEN }}
          path: ${{ env.ACTIONS_PATH }}
          ref: ${{ github.event.inputs.actionsRepositoryBranch }}

      # ##################################################################################
      # Initialize Workflow
      # ##################################################################################

      - name: Initialize Workflow
        uses: ./mcbscore/github/actions/init-workflow
        with:
          installJava: true

      # ##################################################################################
      # Version ermitteln
      # ##################################################################################

      - id: determine-build-type-and-branch-name
        name: Determine Build Type And Branch Name
        uses: ./mcbscore/github/actions/build-type-and-branch-name

      - id: determine-component-version
        name: Determine Component Version
        uses: ./mcbscore/github/actions/determine-component-version
        with:
          component: ${{ env.JIRA_COMPONENT }}

      # ##################################################################################
      # Release bauen
      # ##################################################################################

      - name: Set release version in db changes
        if: env.BUILD_TYPE == 'RELEASE' && hashFiles('.github/**/dbChanges.yml') != ''
        shell: bash
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

          find './${{ env.DB_CHANGES_DIRECTORY }}' -type f -exec sed -i 's/{releaseVersion}/${{ env.COMPONENT_VERSION }}/g' {} +

          changesDetected=`git status --porcelain`

          if [ -n "$changesDetected" ]
          then
            echo "Committing changes"
            git commit -am "ReleaseVersion in DB Changes eingetragen"
            git push
          fi

      - name: Scripte prüfen
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') }}
        run: sh ./gradlew -PLI_username=${{ env.LIQUIBASE_USERNAME }} -PLI_password='${{ env.LIQUIBASE_PASSWORD }}' -PLI_contexts=production -PARTIFACT_VERSION=${{ env.COMPONENT_VERSION }} -PGITHUB_USER=${{ env.USER }} -PGITHUB_TOKEN='${{ env.TOKEN }}' createDatabaseChangeScripts ${{ github.event.inputs.gradleOptions }}

      - id: gradle-build
        name: Gradle Build
        uses: ./mcbscore/github/actions/gradle-build
        with:
          artifactoryUserName: ${{ secrets.MD_ARTIFACTORY_USER }}
          artifactoryPassword: ${{ secrets.MD_ARTIFACTORY_PW }}
          sonarqubeToken: ${{ secrets.SONARQUBE_TOKEN }}
          sonarqubeUrl: ${{ secrets.SONARQUBE_HOST_URL }}
          # TODO smokeTest wieder an, wenn Testdatenbank an neue BusinessTransactions angepasst
          # gradleCommand: clean build smokeTest
          gradleOptions: ${{ github.event.inputs.gradleOptions }}
          enableSonarCheckOnAllBranches: true

      # JUnit Ergebnisse publizieren
      - name: Publish Unit Test Results
        uses: EnricoMi/publish-unit-test-result-action@v1
        if: always()
        with:
          files: '**/test-results/**/*.xml'

      # Existierende Draft Releases löschen
      - name: Delete draft releases
        if: env.BUILD_TYPE == 'DEVELOP'
        uses: hugo19941994/delete-draft-releases@v1.0.0
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}

      # Release erstellen
      - name: Create Release
        id: create-release
        if: env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP'
        # Diese Action definiert einen Output "upload_url".
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          tag_name: ${{ env.TAG_PREFIX }}${{ env.COMPONENT_VERSION }}
          release_name: ${{ env.RELEASE_PREFIX }}${{ env.COMPONENT_VERSION }}
          draft: ${{ env.DRAFT }}
          prerelease: false

      # Release Upload pirun
      - name: Read build.properties (pirun)
        shell: bash
        run: cat metis-pirun/.github/build.properties >> $GITHUB_ENV

      - name: Upload Release JAR (pirun)
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create-release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # Release Upload masterdata
      - name: Read build.properties (masterdata)
        shell: bash
        run: cat metis-masterdata/.github/build.properties >> $GITHUB_ENV

      - name: Upload Release JAR (masterdata)
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create-release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # Release Upload hofactoring
      - name: Read build.properties (hofactoring)
        shell: bash
        run: cat metis-hofactoring/.github/build.properties >> $GITHUB_ENV

      - name: Upload Release JAR (hofactoring)
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create-release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # Release Upload shell
      - name: Read build.properties (shell)
        shell: bash
        run: cat metis-shell/.github/build.properties >> $GITHUB_ENV

      - name: Upload Release JAR (shell)
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create-release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # Release Upload rest
      - name: Read build.properties (rest)
        shell: bash
        run: cat metis-rest/.github/build.properties >> $GITHUB_ENV

      - name: Upload Release JAR (rest)
        if: ${{ (env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP') && env.APPLICATION_JAR_NAME != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ env.TOKEN }}
        with:
          upload_url: ${{ steps.create-release.outputs.upload_url }}
          asset_path: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_name: ${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar
          asset_content_type: application/java-archive

      # ##################################################################################
      # Re-Merge
      # ##################################################################################
      - name: Merge development -> staging
        if: env.BUILD_TYPE == 'RELEASE'
        uses: devmasx/merge-branch@master
        with:
          type: now
          from_branch: release
          target_branch: develop
          github_token: ${{ env.TOKEN }}

      # Docker Image erzeugen
      - name: Docker Image erzeugen
        if: env.BUILD_TYPE == 'RELEASE' || env.BUILD_TYPE == 'DEVELOP'
        uses: ./mcbscore/github/actions/create-microservice-docker-image
        with:
          componentName: ms-${{ env.COMPONENT }}
          componentVersion: ${{ env.COMPONENT_VERSION }}
          jar: ${{ env.APPLICATION_JAR_PATH }}${{ env.APPLICATION_JAR_NAME }}-${{ env.COMPONENT_VERSION }}.jar

      # Starte Deployment auf K8S
      - name: Invoke kubernetes workflow
        if: env.BUILD_TYPE == 'DEVELOP' && hashFiles('.github/**/deployment_k8s.yml') != ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: K8s Deployment
          token: ${{ env.TOKEN }}
          inputs: >
            { 
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ env.COMPONENT_VERSION }}",
              "environment": "dev",
              "dryRun": "false"
            }

      # Starte DB changes Workflow
      - name: Invoke db changes workflow
        if: env.BUILD_TYPE == 'RELEASE' && hashFiles('.github/**/dbChanges.yml') != ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: DB Changes
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "component": "${{ env.COMPONENT }}",
              "componentVersion": "${{ env.COMPONENT_VERSION }}",
              "tagPrefix": "${{ env.TAG_PREFIX }}"
            }
      
      # Starte postBuild auf RELEASE
      - name: Invoke postBuild workflow
        if: env.BUILD_TYPE == 'RELEASE' && hashFiles('.github/**/postBuild.yml') != ''
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: PostBuild
          token: ${{ env.TOKEN }}
          inputs: >
            {
              "releaseVersion": "${{ env.COMPONENT_VERSION }}",
              "issueList": "${{ env.ISSUE_LIST }}",
              "epic": "${{ github.event.inputs.epic }}",
              "actionsRepositoryBranch": "${{ github.event.inputs.actionsRepositoryBranch }}"
            }

      # metis-test auschecken
      - name: checkout metis-test
        if: env.BUILD_TYPE == 'RELEASE'
        uses: actions/checkout@v3
        with:
          repository: freenet-group/metis-test
          token: ${{ env.TOKEN }}
          path: metis-test-repo

      # Tag am metis-test Repo setzen
      - name: tag metis-test repository
        if: env.BUILD_TYPE == 'RELEASE'
        shell: bash
        run: |
          cd metis-test-repo
          tag='metis_${{ env.COMPONENT_VERSION }}'
          git tag -f -a "$tag" -m "$tag"
          git push origin "$tag"
