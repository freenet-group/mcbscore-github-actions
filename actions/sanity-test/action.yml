name: Sanity-Test

inputs:
  enabled:
    description: Ob der Test ausgeführt werden soll
    required: false
    default: "true"
  environment:
    description: Die Zielumgebung
    required: true
  awsAccessKeyId:
    description: AWS Access Key Id
    required: true
  awsSecretAccessKey:
    description: AWS Secret Access Key
    required: true
  karateVersion:
    description: Karate-Version
    required: true
  testDir:
    description: Verzeichnis der Tests
    required: true
  testFiles:
    description: Dateinamen der Tests
    required: true
  tags:
    description: Tags zur Auswahl welche Tests gestartet werden sollen
    required: false
    default: ''
  baseUrl:
    description: Basis-URL
    required: true
  testProperties:
    description: JSON Map mit Einträgen, die dem Test als Properties zur Verfügung stehen sollen
    required: false
    default: ''

runs:
  using: composite
  steps:
    - name: AWS Secrets für Sanity-Test auslesen
      uses: ./.github/actions/read-aws-secrets
      with:
        awsAccessKeyId: '${{inputs.awsAccessKeyId}}'
        awsSecretAccessKey: '${{inputs.awsSecretAccessKey}}'
        awsParameterPairs: |
          /github/secrets/mcbs_token = TOKEN,
          /config/ms/application_${{inputs.environment}}/sts.md.client.mcbs-test-client.clientId = SANITY_CLIENT_ID,
          /config/ms/application_${{inputs.environment}}/sts.md.client.mcbs-test-client.clientSecret = SANITY_CLIENT_SECRET,
          /config/ms/application_${{inputs.environment}}/sts.md.base.url = SANITY_STS_URL,
          /config/ms/application_${{inputs.environment}}/api.gateway.md.${{inputs.environment}}.base.url = SANITY_API_GATEWAY

    - name: Prüfe ob SanityTest.feature existiert und aktiviert ist
      id: checkEnabled
      env:
        ENABLED: '${{inputs.enabled}}'
        TEST_DIR: '${{inputs.testDir}}'
      run: |
        if [ "$ENABLED" == false ]; then
          echo 'enabled=false'
        # Check if feature file exists
        elif find "$TEST_DIR/" -iname '*.feature' -print -quit | grep -q .; then
          echo 'enabled=true'
        else
          echo 'enabled=false'
        fi >> "$GITHUB_OUTPUT"

    # Dynamische AWS Parameter gemäß Workflow Property SANITY_TESTS_AWS_PARAMETERS:
    # Z.B. SANITY_TESTS_AWS_PARAMETERS={ "propA": "/config/foo/a", "propB": "/config/foo/b" }
    # => Umgebungsvariable DYNAMIC_AWS_PARAM_PAIRS setzen mit mehrzeiligem Wert
    #   /config/foo/a = SANITY_TESTS_AWS_PARAM_propA,
    #   /config/foo/b = SANITY_TESTS_AWS_PARAM_propB
    # (um dann an karate-action Input properties auf
    # { "propA": ${{ env.SANITY_TESTS_AWS_PARAM_propA }}, "propB": ${{ env.SANITY_TESTS_AWS_PARAM_propB }} }
    # zu setzen)
    - name: dynamische AWS-Parameter Bedarf ermitteln
      if: steps.checkEnabled.outputs.enabled == 'true'
      run: |
        # TODO: Input-Ersatz für Variable SANITY_TESTS_AWS_PARAMETERS
        out=$(jq --raw-output 'to_entries | map(.value + " = SANITY_TESTS_AWS_PARAM_" + .key) | join(",\n")' \
          <<<"$SANITY_TESTS_AWS_PARAMETERS" \
          | tee /dev/stderr)
        printf '%s<<...snip...\n%s\n...snip...\n' DYNAMIC_AWS_PARAM_PAIRS "$out" >>"$GITHUB_ENV"

    - name: dynamische AWS-Parameter für Sanity-Test auslesen
      if: steps.checkEnabled.outputs.enabled == 'true'
      uses: ./.github/actions/read-aws-secrets
      with:
        awsAccessKeyId: '${{inputs.awsAccessKeyId}}'
        awsSecretAccessKey: '${{inputs.awsSecretAccessKey}}'
        awsParameterPairs: '${{env.DYNAMIC_AWS_PARAM_PAIRS}}'

    # Dynamische AWS Parameter (jetzt in Umgebungsvariablen) als JSON formatieren, wie man es an karate-action übergeben kann:
    # Beispiel Fortsetzung: Umgebungsvariablen:
    # - SANITY_TESTS_AWS_PARAM_propA = <Wert von AWS Param /config/foo/a>
    # - SANITY_TESTS_AWS_PARAM_propB = <Wert von AWS Param /config/foo/b>
    # => Setze Output auf {"propA": <Wert von Umg.Var. SANITY_TESTS_AWS_PARAM_propA>, "propB": <Wert von Umg.Var. SANITY_TESTS_AWS_PARAM_propB>}
    - name: dynamische AWS-Parameter als JSON formatieren
      id: getAwsKarateProperties
      if: steps.checkEnabled.outputs.enabled == 'true'
      run: |
        # TODO: Input-Ersatz für Variable SANITY_TESTS_AWS_PARAMETERS
        out=$(jq --compact-output '
          [
            to_entries
            | map({"key": .key, "value": env["SANITY_TESTS_AWS_PARAM_" + .key]}) []
            | select(.value != null)
          ]
          | from_entries' <<<"$SANITY_TESTS_AWS_PARAMETERS")
        printf 'properties=%s\n' "$out" >>"$GITHUB_OUTPUT"

    - name: checkout mcbscore-github-actions
      if: steps.checkEnabled.outputs.enabled == 'true'
      uses: actions/checkout@v4
      with:
        repository: '${{env.ACTIONS_REPOSITORY}}'
        token: '${{env.TOKEN}}'
        path: '${{env.ACTIONS_PATH}}'
        ref: '${{inputs.actionsRepositoryBranch}}'

    - name: Token holen
      if: steps.checkEnabled.outputs.enabled == 'true'
      id: getToken
      uses: ./mcbscore/github/actions/get-application-token
      with:
        clientId: '${{env.SANITY_CLIENT_ID}}'
        clientSecret: '${{env.SANITY_CLIENT_SECRET}}'
        tokenUrl: '${{env.SANITY_STS_URL}}/v1/oidc/token'

    - name: Karate Tests ausführen
      if: steps.checkEnabled.outputs.enabled == 'true'
      uses: DasBen/karate-action@0.3.0
      with:
        karateVersion: '${{inputs.karateVersion}}'
        baseUrl: '${{inputs.baseUrl}}'
        testDir: '${{inputs.testDir}}'
        testFilePath: '${{inputs.testFiles}}'
        properties: '${{inputs.testProperties}}'
        authToken: 'Bearer ${{steps.getToken.outputs.accessToken}}'
